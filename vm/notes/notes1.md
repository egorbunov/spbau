* Абстрактная интерпретация -- интерпретатор, который принимает операционную семантику входного языка, а далее на основании этого знания что-то делает. Один из способов (используется где-то в JVM) заключается в том, чтобы по входному коду (команде), не исполнять её, а генерировать машинный код
* Простой JIT -- замена байткода (команд) на эквивалентные машинные инстуркции (последовательности). Неглубокая интерпретация. Такая оптимизация вообще кому-то нужна? Она даёт ускорение в 3-4 раза. Почему? Стоимость диспетчеризации.
* IR (Intermediate Representation). Например AST -- это IR. На них можно делать оптимицации (AOT -- ahead of time оптимизации):
    - Арифмитические операции с константами времени компиляции
    - Векторизация
    - Инвертирование циклов (превращение цикла `while` в `do...until`)
    - Инлайнинг
* Работа с `null`-поинтерами. Проверка на них -- это условный переход, а JIT может помоч тем, что будет знать, что что-то точно не `null`. Т.е. один раз проверили на `null`, узнали что он не `null` и имеем гарантии на кусок кода, что переменная не уйдёт `null`. Тогда можно не проверять на `null` на этом куске...
* JIT-компиляция покрывает более широкий класс оптимизаций в отличие от AOT
    - Анализ доступности объектов в другом потоке (к `synchronized(new Object())`)
    - ...
* Деоптимизация -- это прямое отношение интерпретатора с JIT
* В HotSpot реалзоавно два jit-колмпилятора: C1 и C2 (клиентский и серверный). Ибо было две разных команды с разным видением JIT-а.
* Регистровая аллокация -- задача распределения логическим переменным интерпретатора (реальной программы) физических регистров процессора. Нужно, т.к. некоторые (многие/все) инструкции могут использовать только регистры для операндов. Эта задача эквивалентна задаче о раскраске графа в `N` цветов, где `N` -- число физических регистров, а граф состоитиз вершин-переменных и рёбрами соединены те переменные, времена жизни которых пересекаются.
