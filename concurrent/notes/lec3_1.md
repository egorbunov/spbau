# Профилирование

* Сэмплирующий тип -- периодические снимки памяти (?)
* Инструментирование -- в каждую функцию встраивается код для профилирования


### Всякие програмки

* Profiling Studio
* Sikuli
* Jsstress


# Memory model и берьеры памяти

* MESI: каждой линейке кэша добавляется 2 бита, которые обозначают состояния: 
    - Modified (состояние линейки не совпадает с RAM) 
    - Exclusive (если ядро получает эксклюзивный доступ к памяти)
    - Shared (после первого изменения в кэше, нужно уведомить всех об этом)
    - Invalid (кэш линия не используется)
* Расширение: MOESI (MESI + Ownership state)
* Есть брокер, которые передаёт сообщения между процессорами для синхронизации кэшей
    - Брокер пытаются делать ещё более эффективным, чем кэш
    - Это достаточно закрытая часть архитектуры процессора
* *Store Buffer* -- отдельный от кэша буфер (ещё один кэш): 
    - Ядро при изменении ячейки памяти сначала запишет значение в Store Buffer и разошлёт всем ядрам сообщение о том, что значение этой линейки нужно инвалидировать
* *Invalidate Queue* -- ядро получив сообщение о том, что ему нужно что-то инвалидировать, складывает эту информацию туда и сразу отсылает сообщение о том, что всё ок и значение записано
* Вместе с появлением *Store Buffer* и *Invalidate Queue* появились барьеры памяти:
    - `smp_rb()` -- барьер на чтение; происходит сброс (применение всех операций из) *Invalidate Queue*
    - `smp_wb()` -- барьер на запись; происходит применение всех операций из *Store Buffer* (заставит ожидать подтверждений (возможно, обманчивых) об инвалидации от другий процессоров)
    - `smp_b()`
* **Идея:** так же как при работе с примитивами синхронизации, когда вы захватываете в одном потоке примитив синхронизации на чтения, а в другом на запись **НЕ** захватываете, то у ваша система **на надёжна**! Так же и с барьерами памяти: их нужно использовать совместно во всех потоках (на всех ядрах).

### Пример

2 ядра.
Значение `b` в кэше первого ядра, а `a` у второго.
Т.е. `b` для первого ядра Exclusive, а `a` для второго.

```c++
a = 0;
b = 0;
```

Первое ядро:

```c++
void f() {
    a = 1;
    b = 1;
}
```

Второе ядро:

```c++
void g() {
    while (b == 0) continue;
    assert(a == 1);
}
```

Возможный сценарий:

1. *(ЯДРО 1)* `a = 1`
    1. Добавить в store buffer
    2. read invalidate -->
2. *(ЯДРО 2)* `while (b == 0)`
    1. Посылаем запрос на чтение `b` (read) -->
3. *(ЯДРО 1)* `b = 1`
    1. modified; просто изменили значение в кэше, т.к. кэш линия была для нас exclusive, ибо сообщение `read` ещё не пришло (с шага 2)
4. *(ЯДРО 1)* Пришёл запрос read `b`
    1. Поменяли состояние линии в Shared
5. *(ЯДРО 2)* --> Получили `b` и записали в кэш (состояние линии Shared)
6. *(ЯДРО 2)* Выход из цикла `while`
7. *(ЯДРО 2)* `assert(a == 1)` --> **падаем!**
8. *(ЯДРО 2)* Обрабатываем сообщение read invalidate с шага 1
9. *(ЯДРО 1)* Сбрасываем *Store Buffer*


### Модели памяти

* Sequential
* Strongly ordered (x86)
* Weak ordering (Arm, Itanium, ...)
* Super Weak! (Alpha)