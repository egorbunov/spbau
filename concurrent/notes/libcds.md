# Lock-Free алгоритмы

Рассматриваем список, будем делать его lock-free.

Атомарные примитивы:

* atomic load/store
* atomic compare-and-swap (CAS)
    - В c++ у atomic переменной есть strong и weak cas, на архитектуре x86 они работают одинаково

Считаем что хвост и голова всегда в списке есть (фиктивные).

## Вставка

* Почему retry с самого начала?

## Удаление

## Проблемы

* Параллельная вставка и удаление в список
    - Если сначала произошло удаление, а вставляющий поток в этот момент пометил элемент, который уже удалён, как предшествующий для вставляемого
    - **Решение:** Тим Харрси предложил использовать marked pointers: первый бит указателя всегда будет нулевым, ибо аллокаторы памяти в большинстве систем выравнивают её (выделяют батчами) по 8, 16 бит.
```c++
A: cur->next.CAS(next, next | 1);
B: b_pred->next.CAS(b_next, new_el) // 
```

* ABA проблема
    - Удаляющий поток был вытеснен. Другой поток наудалял этот же элемент, и навставлял ещё один, который был выделен по тому же адресу. Проснувшись, первый поток увидит, что элемент как бы тот же для него, ибо адрес сохранился...и удалит его! А ключ то там уже не тот...
* Проблема локальных данных. 
    - Поток держит на стеке указатель на удалённую память

Решения (видимо, обеих проблем ABA и локальных данных):
    - Tagged pointers (dwCAS)
    - Hazard pointers
    - RCU

### Hazard pointers

Прежде чем работать с указателем (обращаться к полям) мы должны этот элемент защитить. Поток имеет массивы:
    
    * Массив hazard pointerов (указателей, с которыми мы работаем, т.е. те, к полям которых мы касаемся). Такой массив локален для потока (и видит его только поток).

```c++
T* protect(atomic<T*> &p) {
    T* ptr;
    do {
        hp[i] = ptr = p.load();
    } while (ptr != p.load());
    return ptr;
}
```


    * Массив retired -- массив указателей, готовых к удалению. Тоже приватные данные для потока. Как только в массиве retired заполняется последний слот запускается процедура `scan`

```c++
void scan(retired a[]) {
    uHP = union_hazard_pointers_for_all_threads()
    for (ptr : a) {
        if (a not in uHP) {
            delete a;
        }
    }
}
```


### User-space RCU

Работа с разделяемыми данным разбивается на эпохи.
Каждая опеация по чтению (вставка, проход по списку и прочее, кроме удаления) обрамляется `rcu_enter()` и `rcu_exit()`. А удаляющий поток сначала работает в критической rcu секции (между rcu_enter и rcu_exit) и делает элемент недостижимым в списке, но удалет его их кучи!, т.к. ссылку на него может ещё кто-то держать, и делает вызов `rcu.sync()`, после `rcu_exit()` который инкрементит эпоху и ждёт, пока из предыдущей эпохи все выйдут (rcu.exit())), а только потом делает удаление.

# Хэш-таблица без ребилда 

* Храним в одном едином списке храним список из хэшей ключей и следующую за ним цепочку сколизированных элементов

```
HashT
| T[1] | -----------------------------
-------                              |
| T[0] | ---------                   |
                 |                   |
                 |                   |
                |0|->(8)->(2)->(3)->|1|->(1)->(42)->
```

Этот список отсортирован по развёрнутым последовательностям битов (АРАБЫ!)

**Название структуры**: Split-ordered list. Nir Shavit.

# Итератор по лок-структуре

* с RCU ок! просто долгая критическая секция
* С harzard pointer не текущий элемент всё плохо может быть с операцией инкремента
* Multi-level array