%!TEX program = xelatex

\input{env.tex}
\makeatletter
\def\input@path{{./figs/}}
\makeatother
\graphicspath{{./figs/}}

\title{Экзаменационные билеты \\ Алгоритмы. 5 курс. Весенний семестр.}
\author{Горбунов Егор Алексеевич}

\begin{document}
\maketitle

\section{Декартово дерево}
\begin{defn}
Декартово дерево -- это бинарное дерево, в каждой вершине которого хранится пара $(k, p)$, причём декартово дерево является деревом поиска по ключу $k$ и кучей по приоритету $p$.
\end{defn}

\begin{lem}
Пускай нам дан набор пар $(k_1, p_1), (k_2, p_2), \ldots, (k_n, p_n)$, причём все $p_i$ различны. Тогда существует единственное декартово дерево, построенное по этому набору пар.
\end{lem}
\begin{proof}
Будем рекурсивно (по индукции) строить декартово дерево. Все приоритеты $p_i$ различны, а значит среди пар можно выбрать \emph{единственную}, у которой приоритет $p_i = p_{max}$ максимальный. Относительно этого приоритета все пары мы можем однозначно разбить на две группы: в <<левую>> группу отправим пары у которых $p_i < p_{max}$, а в правую те, у которых $p_i \geq p_{max}$.
Таким образом разделили исходную задачу размера $n$ на более мелкие две. Построим соответственно декартово дерево на <<левой>> и <<правой>> группе и присоединим к корневой паре с приоритетом $p_{max}$. Дерево построено, значит существует. На каждом уровне выбор корня делается единственным способом (тут используем единственность приоритетов), а значит дерево единственно.
\end{proof}

\begin{note}
Алгоритм, описанный в доказательстве леммы отработает за $\bigO{n^2}$.
\end{note}

\subsection{Построение за линейное время}

Пускай нам дан \emph{уже отсортированный} по ключам в порядке возрастания набор пар $(k_1, p_1), \ldots, (k_n, p_n)$. 
Построим по ним декартово дерево быстро -- за $\bigO{n}$. Декартово дерево -- бинарное дерево поиска по ключам $k_i$, а это значит, что при добавлении ключей в порядке возрастания, добавляемая вершинка должна оказаться самой правой (у нас в левой веточке ключи $< k$, а в правой $\geq k$). Заметим таким образом, что мы всегда можем добавлять новую вершину $x$ в правую ветвь декартова дерева:

\begin{enumerate}[label=\arabic*.]
\item В самой правой ветви найти такие две вершины $a$ и $b$ ($b$ -- непосредственный сын $a$), что $a.p > x.p$ и $x.p > b.p$ (всякие граничные случаи где $a = NIL$ или $b = NIL$ не берём в голову, сейчас пофиг)
\item Перекинуть ссылки на сынишек: $x.l = b,\ a.r = x$
\end{enumerate}

\begin{figure}[ht!]
\centering
\def\svgwidth{1.5in}
\input{treap_n_construction.pdf_tex}
\caption{Вставка вершины при построении декартова дерева}
\end{figure}

Как находить такие вершины $a$ и $b$? Можно спускаться от корня вниз и вправо. Но тогда представим себе такую ситуацию: на вход подали набор пар $(1, 1), (2, 2), (3, 3), \ldots, (n, n)$. Пары отсортированы как надо. На каждой итерации алгоритма построения дерева новая вершина будет добавляться в самый конец пути вправо, таким образом для нахождения вершины $a$ мы каждый раз будем спускаться вниз проходя по $i$ вершин на $i$-ой итерации. Это как-то квадратично, а мы хотим за $\bigO{n}$.

Будем искать место для вставки с конца правой ветки. Почему это разумно? А потому, что веточка снизу ломается влево каждый раз при добавлении новой вершины там, куда её добавили. Это наводит на разные амортизационные мысли. Имеем дерево $T$, которое строится.
\[
	\Phi_i(T) = \text{длина правой ветки дерева перед $i$-ой итерацией}
\]
Тогда амортизационная стоимость итерации (добавления одной вершинки) равна (тут $t$ --- это то, сколько мы прошли по правой ветки снизу в поисках места вставки)
\[
	\tilde{c_i} = t + \Delta_i \Phi = t + ((l - t + 1) - l) = t - t + 1 = 1 = \bigO{1}
\]
Таким образом амортизационная оценка на построение всего дерева: $\bigO{n}$!
\subsection{Операции вставки и удаления}
Для вставки и удаления введём 2 дополнительные операции: \texttt{Split} и \texttt{Merge}

\begin{itemize}
\item \emph{Процедура \texttt{Split}} принимает на вход дерево $T$ и ключик $k$, а возвращает 2 декартовых дерева: в первом дереве все ключики $< k$, а во втором $\geq k$.
\begin{minted}[mathescape, linenos, fontsize=\footnotesize]{python}
def Split(T, k):
    if size(T) == 0: return (nil, nil) # nil is empty tree or something like this...
    if size(T) == 1 and T.k < k: return (T, nil)
    if size(T) == 1 and T.k >= k: return (nil, T)
    if T.k < k:
        (T.r, R) = Split(T.r, k)
        return (T, R)
    else:
        (L, T.l) = Split(T.l, k)
        return (L, T)
\end{minted}
Логика проста: если ключ в корне дерева меньше $k$, то этот корень уже находится в искомой <<левой>> половине разбиения (сплита, разреза, как хотите!), а значит <<правую>> половину разбиения мы берём из рекурсивного разбиения правого сына, а левые остатки присоединяем к итоговой левой части.

\item \emph{Процедура \texttt{Merge}} принимает на вход два дерева $L$ и $R$, причём таких, что ключи в первом дереве меньше либо равны ключам во втором и возвращает декартово дерево содержащее ключи обоих деревьев. Опять просто и рекурсивно:
\begin{minted}[mathescape, linenos, fontsize=\footnotesize]{python}
def Merge(L, R):
	if size(L) == 0: return R
	if size(R) == 0: return L
	if L.p > R.p:
	    L.r = Merge(L.r, R)
	    return L
	else:
	    R.l = Merge(L, R.l)
	    return R
\end{minted}
Тут мы просто уменьшаем задачу валидным способом...

\item \emph{Вставка в дерево}: процедура \texttt{Insert}. Процедура будет принимать дерево и новую вершину, а возвращать изменённое дерево.
\begin{minted}[mathescape, linenos, fontsize=\footnotesize]{python}
def Insert(T, node)
	(L, R) = Split(T, node.k)
	return Merge(Merge(L, node), R)
\end{minted}

\item \emph{Удаление из дерева}: процедура \texttt{Remove}. Принимаем дерево и ключ, а возвращаем дерево, их которого вершинка с ключиком была удалена.
\begin{minted}[mathescape, linenos, fontsize=\footnotesize]{python}
def Remove(T, k)
	(L, R) = Split(T, k)
	(D, R) = Split(R, k)
	return Merge(L, R)
\end{minted}
\end{itemize}

\begin{note} 
Легко видеть, что время работы операций \texttt{Split} и \texttt{Merge} --- $\bigO{h}$, где $h$ --- высота дерева. А значит аналогично и время работы вставки и удаления.
\end{note}

\subsection{Дуча (Treap, Дерамида)}

\begin{defn}
Дуча --- это декартово дерево, приоритеты в котором случайные и равномерно распределённые.
\end{defn}
\begin{lem}
Математическое ожидание высоты дучи равно $\bigO{\log{n}}$, где $n$ --- число вершин в ней.
\end{lem}
\begin{proof}
Обратимся к рекурсивному (тот, что за $\bigO{n^2}$) алгоритму построения декартова дерева. Заметим, что в силу случайности приоритетов мы равновероятно выбираем любой ключ при построении дерева, относительно которого все остальные ключи будут разбиты по группам $<$ или $\geq$. Это в точности та же процедура, которая происходит при применении быстрой сортировки. И дерево рекурсии для этих задач идентичны. Умеем доказывать, что дерево рекурсии \texttt{QuickSort} будет иметь высоту, в среднем (из-за случайности процесса, а не по входам), логарифмическую! 
\end{proof}

\section{Задачи \texttt{RMQ} и \texttt{LCA}}

\end{document}