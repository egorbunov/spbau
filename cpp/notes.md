##### 1
```c++
class foo {
    public: 
        foo(T val1, K val2) : val1_(val1), val2_(val2) {}
};
```
При инициализации без использования списков инициализации, т.е. в теле конструктора, будет вызваны конструкторы по умолчанию у `val1_` и `val2_`, а потом ещё будет вызван оператор присваивания при инициализации, а в случае же списков инициализации будет просто один раз вызван конструктор копирования.

##### 2
Не все операторы в **c++** можно сделать `virtual`:
```c++
class A {};
class B : public A {};

A operator+(A x, A y);
B operator+(B x, B y);
```
Сигнатуры операторов не совпадают, а значит это разные операторы...

##### 3
Когда implicit`но создаётся объект, то он всегда временный, а такие объекты в **c++** всегда должны передаваться по константной ссылке, например:
```c++
#include <iostream>
#include <string>

void foo(std::string& str) { /*...*/ }
void bar(const std::string& str) { /*...*/ }

int main() {
    const char* cstr = "Hello!";
    foo(cstr); // ERROR
    bar(cstr); // OK
    char* str = (char*) "Hi!";
    foo(str); // ERROR
    bar(str); // OK
    return 0;
}
```
