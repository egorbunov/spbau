-- Сконструируйте биекцию между { 0 .. n-1 } + { 0 .. k-1 } и { 0 .. n+k-1 }
sum_bij
    :: Int -- мощность первого множества.
    -> Int -- мощность второго множества.
    -> (Either Int Int -> Int, Int -> Either Int Int) -- требуемая биекция.
                                                      -- предполагается, что в функции не передаются числа, выходящие за пределы множеств, которые указаны в условии.
sum_bij n k = (\e -> case e of Left i -> i
                               Right i -> n + i,
               \i -> if i < n then Left i
                              else Right (i - n))

-- Сконструируйте биекцию между { 0 .. n-1 } * { 0 .. k-1 } и { 0 .. n*k-1 }
mul_bij
    :: Int -- мощность первого множества.
    -> Int -- мощность второго множества.
    -> ((Int,Int) -> Int, Int -> (Int,Int)) -- требуемая биекция.
                                            -- предполагается, что в функции не передаются числа, выходящие за пределы множеств, которые указаны в условии.
mul_bij n k = (\p -> (fst p) * k + (snd p),
               \i -> (i `div` k, i `mod` k)) 

-- Сконструируйте биекцию между { 0 .. n-1 } -> { 0 .. k-1 } и { 0 .. k^n-1 }
exp_bij
    :: Int -- мощность первого множества.
    -> Int -- мощность второго множества.
    -> ((Int -> Int) -> Int, Int -> (Int -> Int)) -- требуемая биекция.
                                                  -- предполагается, что в функции не передаются числа, выходящие за пределы множеств, которые указаны в условии.
exp_bij n k = (\f -> sum $ zipWith (*) [k^i | i <- [0..n-1]] [f x | x <- [0..n]],
               \x -> (\i -> (x `div` (k^i)) `mod` k))

-- x = x_0 + x_1 * k + ... x_i * k^i + ... + x_{n-1} * k^(n-1);

-- Проверяем функции
test :: (a -> Int, Int -> a) -> Int -> Int
test (f,g) n = f (g n)

main = do
    print $ map (test (sum_bij 8 12)) [0..19]
    print $ map (test (mul_bij 12 8)) [0..95]
    print $ map (test (exp_bij 5 4)) [0..1023]
