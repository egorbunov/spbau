\input{env.tex}
\title{Алгоритмы. Домашнее задание №1}
\author{Горбунов Егор Алексеевич}

\begin{document}
\maketitle

\begin{task}[1]
	Пусть \texttt{splay}-дерево поддерживает множество $S$. Каждый элемент $x_i \in S$ был запрошен $p_im$ раз, где $m$~---~общее число запросов. Гарантируется, что $0 < p_i \leqslant 1$ и $\sum_i{p_i} = 1$. Докажите, что $\texttt{splay}$-дерево обрабатывает все запросы за время $\bigO{m \cdot \big[ 1 + \sum_i{p_i\cdot\log{\frac{1}{p_i}}} \big]}$.
\end{task}
\begin{solution}
Время обработки запроса элемена равно времени работы операции $splay$. Посчитаем амортизационную стоимость этой операции.
\begin{figure}[ht!]
	\centering
	\begin{tikzpicture}[scale=1, baseline=(current bounding box.center)]
 	\tikzstyle{every node}=[font=\scriptsize]
	\begin{scope}[VertexStyle/.append style = {minimum size = 5pt}]
        \Vertex[Math,x=0,y=0]{y}
        \Vertex[Math,x=-0.5,y=-1]{x}   
	\end{scope}
	\begin{scope}[VertexStyle/.append style = {draw = none}]
		\Vertex[Math,x=-1,y=-2]{A}
		\Vertex[Math,x=0,y=-2]{B}
		\Vertex[Math,x=0.5,y=-1]{C}
	\end{scope}
    \foreach \x/\y in {y/x,x/A,x/B,y/C} {\Edge(\x)(\y)}
	\end{tikzpicture}
	$\xrightarrow{~~Zig~~}$
	\begin{tikzpicture}[scale=1, baseline=(current bounding box.center)]
 	\tikzstyle{every node}=[font=\scriptsize]
	\begin{scope}[VertexStyle/.append style = {minimum size = 5pt}]
        \Vertex[Math,x=0,y=0]{x}
        \Vertex[Math,x=0.5,y=-1]{y}   
	\end{scope}
	\begin{scope}[VertexStyle/.append style = {draw = none}]
		\Vertex[Math,x=-0.5,y=-1]{A}
		\Vertex[Math,x=0,y=-2]{B}
		\Vertex[Math,x=1,y=-2]{C}
	\end{scope}
    \foreach \x/\y in {y/x,x/A,y/B,y/C} {\Edge(\x)(\y)}
	\end{tikzpicture}
	\hspace{1cm}
	\begin{tikzpicture}[scale=1, baseline=(current bounding box.center)]
 	\tikzstyle{every node}=[font=\scriptsize]
	\begin{scope}[VertexStyle/.append style = {minimum size = 5pt}]
        \Vertex[Math,x=0,y=0]{z}
        \Vertex[Math,x=-0.5,y=-1]{y}  
        \Vertex[Math,x=0,y=-2]{x}  
	\end{scope}
	\begin{scope}[VertexStyle/.append style = {draw = none}]
		\Vertex[Math,x=-1,y=-2]{A}
		\Vertex[Math,x=0.5,y=-3]{B}
		\Vertex[Math,x=-0.5,y=-3]{C}
		\Vertex[Math,x=0.5,y=-1]{D}
	\end{scope}
    \foreach \x/\y in {y/x,x/C,x/B,y/A,z/D,z/y} {\Edge(\x)(\y)}
	\end{tikzpicture}
	$\xrightarrow{ZigZag}$
	\begin{tikzpicture}[scale=1, baseline=(current bounding box.center)]
 	\tikzstyle{every node}=[font=\scriptsize]
		\begin{scope}[VertexStyle/.append style = {minimum size = 5pt}]
        \Vertex[Math,x=0,y=0]{x}
        \Vertex[Math,x=-1,y=-1]{y}  
        \Vertex[Math,x=1,y=-1]{z}
	\end{scope}
	\begin{scope}[VertexStyle/.append style = {draw = none}]
		\Vertex[Math,x=-1.5,y=-2]{A}
		\Vertex[Math,x=-0.5,y=-2]{B}
		\Vertex[Math,x=0.5,y=-2]{C}
		\Vertex[Math,x=1.5,y=-2]{D}
	\end{scope}
    \foreach \x/\y in {x/y,x/z,y/A,y/B,z/C,z/D} {\Edge(\x)(\y)}
	\end{tikzpicture}
	\caption{Повороты}
	\label{fig:task1}
\end{figure}

Всё дерево будем обозначать как $T$, а поддерево с корнем в $x$ как $T(x)$. Рассмотрим весовую функцию равную числу запросов на вершинах в поддереве $T(x)$:
\[ \omega(x) = \sum_{i \in T(x)}{p_i m} \]
Введём следующий потенциал для вершины и для дерева:
\begin{align*}
	\Phi(x) & = \log{\omega(x)} \\
	\Phi(T) & = \sum_{x \in T}{\Phi(x)}
\end{align*}
Важно заметить, что если $x$ предок $y$, то $\Phi(x) \geqslant \Phi(y)$, а так же, функция $\omega(x)$ аддитивна. Таким образом, весь анализ, который мы проделывали для операций $Zig$, $ZigZag$ и $ZigZig$ с использованием весовой функции равной числу вершин в поддереве, верен и для введённых сейчас $\omega$ и $\Phi$. Т.е. легко показывается, что учётная стоимость операции $Zig$:
\[
	{\tilde c}(Zig) \leqslant 3(\Phi'(x) - \Phi(x)) + 1
\]
А учётная стоимость операции $ZigZag$ и $ZigZig$:
\[
	{\tilde c}(ZigZag) = {\tilde c}(ZigZig) \leqslant 3(\Phi'(x) - \Phi(x))
\]
Таким образом, учётная стоимость операции $splay(x)$ равна:
\begin{align*}
	{\tilde c}(Splay(x)) \leq 3(\Phi_{final}(x) - \Phi_{start}(x)) + 1  
	= 3(\log{\sum_{i \in T}{p_im}} - \Phi_{start}(x)) + 1 
	\\ = 3(\log{m}-\Phi_{start}(x)) + 1 \leqslant
	\begin{Bmatrix}
	\text{всяко: }\Phi_{start}(x) \geqslant \log{p_{x}m} \\
	\end{Bmatrix} \\
	\leqslant 3(\log{m}-\log{p_x m}) + 1 = 3\log{\frac{m}{p_xm}} + 1 = 1-3\log{p_x}
\end{align*}
Таким образом, амортизированная стоимость всех запросов элемента $x$ равна $p_xm \cdot (1 - 3\log{p_x})$, а тогда амортизированная стоимость всех запросов равна:
\[
	\sum_{i \in T}{p_i m \cdot (1 - 3\log{p_i})} = m - 3m\sum_{i\in T}{p_i\log{p_i}} = m + 3m\sum_{i\in T}{p_i\log{\frac{1}{p_i}}} = \bigO{m\cdot(1+\sum_{i\in T}{p_i\log{\frac{1}{p_i}}})} 
\]
\xqed
\end{solution}

\begin{task}[2]
Придумать структуру, поддерживающую упорядоченный список $S$ целых чисел со следующими операциями с временем обработке $\bigO{\log{|S|}}:$
\begin{itemize}
	\item \texttt{insert(x)} --- встевить $x$ в $S$, если его там не было
	\item \texttt{delete(x)} --- удалить $x$ из $S$, если он там был
	\item \texttt{S[k]} --- вернуть $k$-тый по порядку элемент из $S$
	\item \texttt{max(l,r)} --- найти $\max_{l \leqslant j < k \leqslant r}{|S[j]-S[k]|}$
	\item \texttt{min(l,r)} --- найти $\min_{l \leqslant j < k \leqslant r}{|S[j]-S[k]|}$
\end{itemize}
\end{task}
\begin{solution}
Не умаляя общности будем считать, что $S$ упорядочен по возрастанию.
Заметим, что тогда для любого отрезка $[l, r]$ верно:
\[
	S[l] \leqslant S[l + 1] \leqslant S[l + 2] \leqslant \ldots \leqslant S[r - 2] \leqslant S[r - 1] \leqslant S[r]
\]
Отсюда выполнение операции \texttt{max(l,r)} вырождается в нахождение разности:
\[
	\max_{l \leqslant j < k \leqslant r}{|S[j]-S[k]|} = S[r] - S[l]
\]
А выполнение операции \texttt{min(l,r)} вырождается в нахождение минимальной разности между лишь соседними элементами:
\[
	\min_{l \leqslant j < k \leqslant r}{|S[j]-S[k]|} = \min_{i \in [l, r)}{(S[i+1]-S[i])}
\]
Будем поступать так: заведём и будем поддерживать следующие структуры над $S$: 
\begin{itemize}
	\item $BT$ --- сбалансированное дерево поиска, ключом в котором являются элементы $S$. С таким деревом мы умеем проделывать операцию вставки $BT.insert(key)$, удаления $BT.delete(key)$, нахождения $BT[k]$ --- $k$-го по порядку элемента за $\bigO{\log{n}}$, где $n$ --- число элементов в дереве.
	\item $CT$ --- декартово дерево по неявному ключу, моделирующее массив $S'$ такой, что $S'[i] = S[i + 1] - S[i]$. В этом дереве поддержим операцию минимума на подотрезке. Нам известно, что в таком дереве можно выполнять операции:
		\begin{itemize}
			\item $CT[k] = v$ --- изменения $k$-ого по порядку элемента
			\item $CT.min(l, r)$ --- нахождение минимума на подотрезке
			\item $CT.insert(k, value)$ --- вставка элемента $value$ на $k$-ую позицию
			\item $CT.delete(k)$ --- удаление элементы на $k$-ой позиции
		\end{itemize}
	Причём асимптотическая сложность (в среднем) этих операций $\bigO{\log{n}}$, где $n$ --- число элементов в дереве.
\end{itemize}
Теперь покажем, как за $\bigO{\log{|S|}}$ выполнять операции из условия задачи:
\begin{itemize}
	\item \texttt{insert(x)}: При вставке $x$ на какую-то позицию $i$ массива $S$ у нас происходит вставка элемента в массив $S'$ на позицию $i$ и изменения $S'[i - 1]$. Т.е. последовательно выполняются операции: $i \leftarrow BT.insert(x);\ CT.insert(i, S[i + 1] - S[i]);\ CT[i - 1] = S[i] - S[i - 1]$. Видим, что все операции занимают $\bigO{\log{|S|}}$; ($size(CT) = |S'| = |S| - 1$)
	\item \texttt{delete(x)}: $i \leftarrow BT.delete(x)$, где $i$ --- позиция, с которой был удалён $x$. Далее: $CT.delete(i);\ CT[i] = S[i + 1] - S[i]$
	\item \texttt{S[k]}: просто выполняем $BT[k]$ (умеем)
	\item \texttt{max(l,r)}: возвращаем $S[r] - S[l]$
	\item \texttt{min(l,r)}: возвращаем $CT.min(l, r - 1)$
\end{itemize}
Видно, что все операции выполняются за $\bigO{\log{n}}$. \xqed
\begin{paragraph}{Альтернативное понимание.} Если список и вставка происходит на определённую позицию. Список моделируем декартовым деревом по неявному ключу с операцией минимума и максимума. Тогда \texttt{insert}, \texttt{delete}, \texttt{S[k]} реализуются классическим образом. А остальные операции так:
\begin{itemize}
 	\item \texttt{max(l, r)} = $max(T) - min(T)$
 	\item \texttt{min(l, r)} = $min(min(T.L), min(T.R), T.k - max(T.L), min(T.R) - T.k)$
\end{itemize} 
\end{paragraph}
\end{solution}

\begin{task}[3]
Пусть приоритеты случайны, а ключи все разные. Найти матожидание количества листьев в Декартовом дереве из $n$ вершин.
\end{task}
\begin{solution}
Пусть $x_i$ --- вершина $i$-ая по порядку. Тогда $x_i$ является листом только тогда, когда $priority(x_i) > priority(x_{i+1})$ и $priority(x_i) > priority(x_{i-1})$. Расположим элементы в порядке возрастания:
\[
	x_1,\ x_2,\ x_3, \ldots, x_n
\]
Для всех вершин $x_i$, где $1 < i < n$: $P[x_i \text{ --- лист}] = \frac{1}{3}$, а для $x_1$ и $x_2$: $P[x_1 \text{ --- лист}] = P[x_n \text{ --- лист}] = \frac{1}{2}$.
В итоге:
\[
	E[\text{число листьев}] = \sum_{i}{P[x_i \text{ --- лист}]} = \frac{n - 2}{3} + 1
\]
\end{solution}

\begin{task}[4]
Пускай приоритеты случайны, а ключи различны. $x_k$ --- вершина Декартова дерева, содержащая $k$-ый по порядку ключ. Всего в дереве $n$ вершин.
\begin{itemize}
	\item Пусть $1 \leqslant i \leqslant j \leqslant k \leqslant n$. Найти вероятность того, что $x_j$  --- общий предок $x_i$ и $x_k$
	\item Пусть $1 \leqslant i \leqslant k \leqslant n$. Найти матожидание длины пути между $x_i$ и $x_k$
\end{itemize}
\end{task}
\begin{solution}
\begin{itemize}
\item Заметим, что $x_j$ является предком $x_i$ только если:
\[ \min{\lbrace p(x_i), p(x_{i+1}), p(x_{i+2}), \ldots, p(x_k) \rbrace} = p(x_j) \]
Где $p(x_i)$ --- приоритет вершины Декартова дерева. Действительно: самая высокя вершина на кратчайшем пути в дереве от $x_i$ до $x_j$ точно содержится в множестве $\lbrace p(x_i), p(x_{i+1}), \ldots, p(x_k) \rbrace$. Т.к. кратчайший путь -- это сначала подъём до какой-то вершины, а потом спуск до нужной, то если эта самая высокая (близкая к корню) вершина на этом пути не является $x_j$, то $x_j$ уже не предок $x_i$, а это эквивалентно тому, что если $p(x_j) \neq \min{\lbrace p(x_i), p(x_{i+2}), \ldots, p(x_k) \rbrace}$, то $x_j$ --- не предок $x_i$ (вершины из $x_i\ldots x_j$, не попавшие в кратчайший путь не могут содержать вершин с меньшим приоритетом, т.к. все они лежат ниже этого кратчайшего пути).

Таким образом $x_j$ --- предок $x_i$, если $\min{(p(x_i)\ldots p(x_j)) = p(x_j)}$. Аналогично $x_j$ --- предок $x_k$, если $\min{(p(x_j)\ldots p(x_k)) = p(x_j)}$. В последовательности $p(x_i)\ldots p(x_j)$ $|j - i| + 1$ чисел, каждое из которых равновероятно может оказаться минимумом, таким образом:
\begin{align*}
	Prob\big[ x_j \text{ --- предок } x_i \big] & = Prob\big[\min{(p(x_i)\ldots p(x_j)) = p(x_j)}\big] = \frac{1}{|j - i| + 1} \\
	Prob\big[ x_j \text{ --- предок } x_k \big] &= \frac{1}{|j - k| + 1}
\end{align*}
Но тогда:
\begin{align*}
	Prob\big[ x_j \text{ --- общий предок } x_i \text{ и } x_k\big] &=  Prob\big[ x_j \text{ --- предок } x_i \big]Prob\big[ x_j \text{ --- предок } x_k \big] = \\ 
	& = \frac{1}{(|j - k| + 1)(|j - i| + 1)}
\end{align*}

\item Введём следующие случайные индикаторные случайные величины:
\[
	V_{ij} = 
	\begin{cases}
		1 \text{, если } x_i \text{ предок } x_j \\
		0 \text{, иначе}
	\end{cases}
	\hspace{0.5cm}
	U_{ijk} = 
	\begin{cases}
		1 \text{, если } x_j \text{ общий предок } x_i \text{ и } x_k \\
		0 \text{, иначе}
	\end{cases}
\]
Заметим теперь, что кратчайший путь от $x_i$ до $x_k$ состоит из предков $x_i$ не являющихся общими предками $x_i$ и $x_k$, а так же из вершин, которые являются предками $x_k$ не являющихся общими предками $x_k$ и $x_i$ плюс $1$. Запишем:
\begin{equation*}
P(i, k) = 1 + \sum_{1 \leq j \leq n}{(V_{ji} - U_{ijk})} + \sum_{1 \leq j \leq n}{(V_{jk} - U_{ijk})}
\end{equation*}
Ясно, что если при $j > k$ $V_{ji} = 1$, т.е. $x_j$ --- предок $x_i$, то $x_j$ будет и предком $x_k$ (т.е. $C_ijk = 1$) так же, т.к. $i \leq k$. Аналогично если при $j < i$ $V_{jk} = 1$, то $U_{ijk} = 1$, т.е:
\[
P(i, k) = 1 + \sum_{1 \leq j \leq k}{(V_{ji} - U_{ijk})} + \sum_{i \leq j \leq n}{(V_{jk} - U_{ijk})}
\] 
Тогда матожидание $P(i, k)$ равно:
\begin{equation*}
\begin{split}
E[P(i,k)] = 1 + \sum_{1 \leq j \leq k}{(E[V_{ji}] - E[U_{ijk}])} + \sum_{i \leq j \leq n}{(E[V_{jk}] - E[U_{ijk}])} = \\
= 1 + \sum_{ 1 \leq j \leq k}{\big[ \frac{1}{|j-i|+1} -  \frac{1}{(|j - k| + 1)(|j - i| + 1)} \big]} 
+ \sum_{i \leq j \leq n}{\big[ \frac{1}{|j-k|+1}- \frac{1}{(|j - k| + 1)(|j - i| + 1)} \big]}
\end{split}
\end{equation*}
Последнее равенство, конечно, нужно упростить, но времени нет! \xqed
\end{itemize}
\end{solution}

\begin{task}[5]
Задача про случайное дерево поиска.
\end{task}
\begin{solution}
1) Вероятность того, что вершина -- корень равна $\frac{1}{n}$ (показыкается по индукции и разбором операции split и merge). Тогда вероятность дерева: $\prod_{i}{\frac{1}{size(i)}}$
\end{solution}


\begin{task}[6]
Придумайте структуру данных, которая поддерживает следующие операции за $\bigO{|text|}$:
\begin{itemize}
	\item Вставка символа на позицию $i$
	\item Удаление символа с позиций $[l, r)$
	\item Копирование подстроки $[l, r)$ в позицию $i$
\end{itemize}
\begin{solution}
Рассмотрим декартово дерево по неявному ключу $CT$, в котором будем хранить текст $text$. Только условимся, что операции $split(CT, k)$ и $merge(T_1, T_2)$ всегда возвращают новое дерево и пересоздают все узлы, которые затрагивают.
\begin{itemize}
	\item Вставка на позицию $i$ будет выполняться как обычная вставка в декартово дерево по неявному ключу.
	\item Удаление интервала $[l, r)$:
	\[
	\begin{array}{l}
		T_1, T_2 \leftarrow split(CT, l) \\
		T_3, T_4 \leftarrow split(T_2, r) \\
		return(merge(T_1, T_4))
	\end{array} 
	\]
	\item компирование подстроки $[l, r)$ в позицию $i$:
		\[
	\begin{array}{l}
		T_{<i}, T_{\geqslant i} \leftarrow split(CT, i) \\
		T_{<l}, T_{\geqslant l} \leftarrow split(CT, l) \\
		T_{[l, r)}, T_{\geqslant r} \leftarrow split(T_{\geqslant l}, r) \\

		return(merge(merge(T_{<i}, T_{[l, r)}), T_{\geqslant i}))
	\end{array} 
	\]
	В силу того, что изменяемые элементы будут пересоздаваться, то при изменении одной части дерева другая не сможет испортиться.
\end{itemize}
Ясно, что по построению эти операции работают в среднем за $\bigO{\log{n}}$. \xqed
\end{solution}
\end{task}
\end{document}
