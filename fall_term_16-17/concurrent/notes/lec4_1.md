# Лекция 4

## Проблемы locking

* Пусть в приложении есть не одна, а две структуры данных, которые нужно поддерживать в консистентном состоянии (если удалять, то из обеих структур). Это приводит к некоторым сложностям, если мы хотим работать со всем этим в конкурентном режиме

## Транзакционная память

* Software Transactional Memory (STM)
    - Haskell использует
* Hardware Transactional Memory
    - Haswell processor
    - Реализована на линейках кэша
    - К линейке кэша добавляется ещё одно состояние: участвует ли она в транзакции?
    - Ядро исполняет транзакцию, тогда все данные, которые оно подгружает в кеш, помечаются как участники транзакции. Если же другие ядра пытаются менять что-то из этих линеек кэша (по какому-нибудь протоколу MESI), то транзакция прерывается
    - Если во время выполнения происходит переключение контекста на другой процесс на ядре, то кэши сбрасываются и транзакция ломается
    - Транзакционная память в железе не работает


## Всякие инструменты

* TBB
    - Свои аллокаторы, т.к. стандартный аллокатор -- это потенциальный lock; можно по тред айди выделять кусок, в котором уже выделять потом
    - cache aligned allocator
* ipp
* mk
* silk
* openmp (go fortran)