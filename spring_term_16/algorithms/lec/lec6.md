### Лекция 6

Теорема Эйлера: Если $n = pq$, $p$ и $q$ -- простые, то $a^{(p-1)(q-1)} = q\mod n$

**Алиса:**
$p$, $q$, $n= pq$.
$e, d$: $(m^e)^d \rightarrow m^1$
$e, d$ -- взаимно обратные
$ed = 1 \mod (p-1)(q-1)$

$e: gcd(e, (p-1)(q-1)) = 1$
$d: e^{-1} \mod (p-1)(q-1)$
$ExtendedGCD((p-1)(q-1), e)$

**Ключи Алисы:**
Публчный: $(n, e)$
Приватный: $(d)$
$E(m) = m^e \mod n$
$D(c) = c^d \mod n = m^1$ ($c^d = m^l$)

* Для взлома достаточно: $(p-1)(q-1)$, тогда мы легко можем всё найти из $(p-1)(q-1) = k; pq = n$.

* Схема ломается, если Чарли встанет между Алисой и Бобом и будет подменять ключи. Это решается через Центр Сертификации, который предустанавливается вместе с дистрибутивом браузера и прочих программ.

#### Быстрое Преобразование Фурье
Умножение чисел работает за $\mathcal{O}(n^2)$, если в лоб, $\mathcal{O}(n^{\log_2{3}})$ Карацубой, а БПФ делает это за $\mathcal{O}(n\log{n})$.

##### Умножение многочленов
Даны многочлены:
$$ A(x) = a_{n-1}x^{n-1} + a_{n-2}x^{n-2} + \ldots a_0 $$
$$ B(x) = b_{n-1}x^{n-1} + b_{n-2}x^{n-2} + \ldots b_0 $$
Вопрос: как быстро вычислить $C(x) = A(x)B(x)$, т.е. вычислить коэффициенты:
$$ c_k = \sum_{i = 0}^{k}{a_{k-1}b_i}, k \in \lbrace 0, \ldots, 2n-2 \rbrace$$
В лоб это делается за $\mathcal{O}(n^2)$, ибо вычисление каждого $c_k$ занимает $\mathcal{O}(k)$.

Вспомним, что полином степени $n$ можно восстановить (интерполировать) по его значению в $n$ точках. Пускай мы знаем значения $(A(x_0), \ldots, A(x_{n-1}))$. Представим $A(x)$ так:
$$
A(x) = \sum_{i=0}^{n-1}{A_i(x)},\ A_i(x) = 
\begin{cases}
A_i(x_j) = 0, &i \neq j\\\
A_i(x_i) = A(x_i)
\end{cases}
$$ 
Т.е:
$$
    A_i(x) = A(x_i) \cdot \frac{(x-x_0)(x-x_1)\ldots(x - x_{n-1})}{(x_i - x_0)(x_i - x_1)\ldots(x_i - x_{i-1})\ldots}
$$
Это интерполяционные полиномы Лагранжа, но вычисляются они за $\mathcal{O}(n^2)$.

Ясно, что $C(x_i) = A(x_i)B(x_i)$. Таким образом мы за $\mathcal{O}(n)$ вычислить $C(x)$ в точках $x_i$, но точек $x_i$ только $n$, но нам ничего не стоит добавить ещё точек и получить всего $2n-2$ точки, по которым уже можно восстановить $C(x)$ интерполяцией.

$$
\begin{array}{lcl}
                       & \rightarrow^{Вычисление} & \\\
(a_0, \ldots, a_{n-1}) &  & (A(x_0), \ldots, A(x_{2n-2}))\\\
(b_0, \ldots, b_{n-1}) &  & (B(x_0), \ldots, B(x_{2n-2}))\\\
                       & \leftarrow^{Интерполяция} & 
\end{array}
$$
Научимся выполнять вычисление и интерполяцию за $\mathcal{O}(n\log n)$.

###### Вычисление

Рассмотрим ($n$ чётно)
$$
\begin{array}{l}
A(x_0) = a_{n-1}x_0^{n-1} + a_{n-2}x_0^{n-2} + \ldots + a_0\\
A(-x_0) = -a_{n-1}x_0^{n-1} + a_{n-2}x_0^{n-2} - \ldots + a_0
\end{array}
$$
Откуда можно вывести: $A(x_0) = A_1(x_0^2) + xA_2(x_0^2)$ и $A(-x_0) = A_1(x_0^2) - xA_2(x_0^2)$, где:
$$
\begin{array}{l}
    A_1(x) = a_0 + a_2x + a_4x^2 + \ldots\\\
    A_2(x) = a_1 + a_3x + a_5x^2 + \ldots
\end{array}
$$
Тогда пользуя метод разделяй и влавствуй кажется, что можно посчитать значения на полиномах $A_1$ и $A_2$ степени $\frac{n}{2}$, а потом их сложить за линию. Тогда получится, что $T(n) = 2T(\frac{n}{2}) + \mathcal{O}(n)$, т.е. $T(n) = \mathcal{O}(n\log n)$.

Но как подобрать такие числа, что:

$$
\begin{array}{c|cccccc}
A & x_0 & & -x_0 & x_1 & & -x_1 \\\
A_1, A_2 & & x_0^2 & & & x_1^2 & \\\
A_{11},A_{12},A_{21},A_{22} & & & ? & ? & & & \\\
\end{array}
$$
В вещественных числах это невыполнимо, а в комплексных вполне: вспомним, что есть корни из $1$ степени $n$: $\omega_o, \omega_1, \ldots, \omega_{n-1}$.
$$
-\omega_i = \omega_{\frac{n}{2}+i} \Rightarrow (-\omega_i)^2 = \omega_{\frac{n}{2}+i}^2
$$
Таким образом процедура вычисления в корнях из -1 будет такая:
```python
FFT((a[0], ..., a[n-1]), w):
    if n == 1:
        return (a[0])
    (A[0], A[1], ..., A[n/2 - 1]) = FFT((a[0], a[2], a[4], ...), w^2)
    (B[0], B[1], ..., B[n/2 - 1]) = FFT((a[1], a[3], a[5], ...), w^2)
    for i in [0, 1, ..., n/2-1]:
        R[i] = A[i] + w*B[i]
        R[n/2+i] = A[i] - w*B[i]
    return (R[0], ..., R[n-1])
```

###### Интерполяция
Посмотрим на такую матрицу:
$$
\begin{pmatrix}
    1 & 1 & 1 & \ldots & 1 \\\
    1 & w_1 & w_1^2 & \ldots & w_1^{n-1} \\\
    1 & w_2 & w_2^2 & \ldots & w_2^{n-1} \\\
    \vdots \\\
    1 & w_{n-1} & w_{n-1}^2 & \ldots & w_{n-1}^{n-1} \\\
\end{pmatrix}
\times
\begin{pmatrix}
    a_0 \\\
    a_1 \\\
    \vdots\\\
    a_{n-1}
\end{pmatrix}
=
\begin{pmatrix}
    A(w_0) \\\
    A(w_1) \\\
    \vdots \\\
    A(w_{n-1})
\end{pmatrix}
$$
Обозначим эту матрицу с $w$-шками за $M(w)$, а за $M(w^{-1})$ матрицу, где все $w_i$ в степени $1$. Заметим:
$$ M(-w)M(w) = nI $$
Действительно, обозначая коэффициенты произведения за $m_{ij}$ получаем:
$$ m_{ij} = \ldots = \sum_{k=0}^{n-1}{w^{k(j-1)}} = \frac{w^{n(j-i)} - 1}{w^{j-i} - 1}  = 
\begin{cases}
n, i = j \\\
0, i \neq j
\end{cases}
$$
(На самом деле это матрица Вандермонда и про неё это всё и так известно). Тогда (в силу того веселья с матрицей Вандермоднда):
```python
Mult((a[0], ... , a[n-1]), (b[0], ..., b[n-1])):
    fft = FFT((a[0], ... , a[n-1]), w) * FFT((b[0], ... , b[n-1]), w) # O(n) 
    return FFT(fft, w^(-1)) / n
```
**PS**: никакого умножения на матрицу тут нет; она используется только для доказательства.

##### Замечания

1. Умножение чисел -- это умножение полиномов, после которого нужно просто перенести разряды
2. Работа с комплексными числами вносит некоторую погрешность, но при аккуратной работе с ними можно и целочисленные полиномы умножать (аккуратно следить за погрешностью), но можно так же это сделать для любого замкнутого поля, в котором нужно будет найти корень из 1
3. Причём тут Фурье? Лекции Мишы Капралова в csc клубе.