%!TEX program = xelatex
\input{settings}

\newcommand{\kw}[1]{\text{\textbf{\color{blue}{#1}}}}

\title{Операции над треками}
\author{Егор Горбунов}

\begin{document}
\maketitle

\section*{Описание операций и языка}

\subsection*{Основные операции}

\begin{itemize}
	\item \textbf{\underline{Арифметические операции}} 
	\vspace{3pt}
	\\\emph{Вариант №1}: $a \in \mathbb{R}, X \in \mathbb{R}^n, Y \in \mathbb{R}^n$. Кодомен всех операций --- $\mathbb{R}^n$.
		\begin{itemize}
			\item $X \diamond Y := \xparen{x_1 \diamond y_1, x_2 \diamond y_2, \ldots, x_n \diamond y_n}, \diamond \in \xbrace{+, -, \cdot, /}$
			\item $a \diamond Y := \xparen{a \diamond y_1, a \diamond y_2, \ldots, a \diamond y_n}, \diamond \in \xbrace{\text{\textasciicircum}, +, -, \cdot, /}$
			\item $X \diamond a := \xparen{x_1 \diamond a, x_2 \diamond a, \ldots, x_n \diamond a}, \diamond \in \xbrace{\text{\textasciicircum}, +, -, \cdot, /}$
		\end{itemize}
	Тут возникает вопрос о том, что делать с отрицательными значениями: имеет ли смысл их отрисовывать в браузере? имеют ли вообще смысл операция <<$-$>> и домножение на отрицательное число? Мне, кажется, что они не нужны и вполне заменяются предикатами и условным оператором, описанными ниже.
	\vspace{3pt}
	\\\emph{Вариант №2}: Всё то же, что и выше, но убираем операцию <<$-$>> и теперь $a \in \mathbb{R}_+$, а $X, Y \in \mathbb{R}_+^n$
	\\\emph{Вариант №3}: операции все, что в 1-ом варианте, но: $x \diamond y \rightarrow \max{\xparen{0, x \diamond y}}$
	\vspace{5pt}
	\\Тут нужно решить, но я склоняюсь ко 2-ому варианту.
	\item \textbf{\underline{Предикаты}} Тут всё понятно. Пусть есть $X \in \mathbb{R}^n, Y \in \mathbb{R}^n$, тогда:
	\begin{align*}
		&\diamond: \xparen{\mathbb{R}^n, \mathbb{R}^n} \rightarrow \xbrace{0, 1}^n \\
		X &\diamond Y = \xparen{x_1 \diamond y_1, x_2 \diamond y_2, \ldots, x_n \diamond y_n}\\
		&\diamond \in \xbrace{ <, >, \leqslant, \geqslant, =, \neq }
	\end{align*}
	\item \textbf{\underline{Связки на предикатах}} Опять же, ничего необычного: $A, B \in \xbrace{0, 1}^n$, тогда определяем:
	\[
		A \kw{ OR } B,\ A \kw{ AND } B,\ \kw{NOT } A \in  \xbrace{0, 1}^n
	\]
	\item \textbf{\underline{Условный оператор}} Пускай теперь $P \in \xbrace{0, 1}^n, X \in \mathbb{R}^n, Y \in \mathbb{R}^n, a \in \mathbb{R}, b \in \mathbb{R}$, тогда полезна следующая операция:
	\begin{align*}
		\kw{ if } P \kw{ then } X \kw{ else } Y &:= P \cdot X + (1 - P) \cdot Y \\
		\kw{ if } P \kw{ then } a \kw{ else } Y &:= P \cdot a + (1 - P) \cdot Y \\
		\kw{ if } P \kw{ then } X \kw{ else } b &:= P \cdot X + (1 - P) \cdot b \\
		\kw{ if } P \kw{ then } a \kw{ else } b &:= P \cdot a + (1 - P) \cdot b
	\end{align*}
	С помощью этой операции легко выражаются всевозможные фильтры.
	\\\emph{PS: тут можно поспорить про синтаксис}.
	\item \textbf{\underline{Псевдонимы для треков}} Называния треков довольно длинные, поэтому полезно будет в запросах уметь ссылаться на конкретные треки через псевдонимы. Предлагаю описывать псевдонимы в самом начале запроса (как минимум потому, что autocompletion сможет их подхватить) так:
	\[
		x = longTrackName1, \ldots, z = longTrackNameK \kw{ in } Expression(x, \ldots, z)
	\]
	\item \textbf{\underline{Имя для нового трека}} Результатом каждого запроса $Q$ является новый трек, пользователь должен иметь возможность задать ему имя. Это будет делаться так:
	\[
		newTrack \kw{ := } Q
	\]
	Если имя не указано, то оно будет сгенерировано или записано с именем lastResult, что перепишет предыдущий неименованый результат.

	\item \textbf{\underline{Показазать отрезки, где выполнен предикат}} Это может быть реализовано через условный оператор.

	\item \textbf{\underline{Показать трэк}} Все операции генерируют трэки, но не добавляют их к отображению. Чтобы добавить какой-то трэк, который был сгенерирован нужно специальное слово, например:
	\[
		\kw{show } TRACK
	\]
\end{itemize}

\subsection*{Дополнительные операции:}
\begin{itemize}
	\item \textbf{\underline{Изменение размера корзины}} Такая возможность понадобится, если пользователь захочет совершать операции над треками с разными размерами корзин. Кажется, что в силу серьёзности данных, это нужно делать аккуратно. Совсем честно мы можем изменить число корзин гистограммы (трека) с $n$ на $m$ только если $n > m$ и $m | n$, т.е. если текущий размер корзины делит новый размер. При этом ещё возникают некоторые проблемы на границах рассматриваемого участка.\\
	Вопрос: нужна ли возможность изменять размер корзины на произвольный? Если да, то видимо наиболее разумный способ реализации -- это каждую корзину равномерно разбить на корзины размера $1$, после чего уже пересчитать гистограмму для нового размера корзины.
	\[
		\kw { resize}(track,\ bpNewBinSize) 
	\]
	\item \textbf{\underline{Операции на подотрезках}} Назвал страшно, а речь идёт о построении новых треков посредством сканирования окном гистограммы (трека) и подсчёта в окне какой-нибудь функции: $\max$, $\min$, $+$, $\times$, $\ldots$ Синтаксис в духе:
	\[
		\kw { window}(track,\ windowSize,\ Function) 
	\]
	Эта штука перекликается с изменением размера гистограммы, но тут $windowSize$ --- это число бинов (столбцов гистограммы), а не $bp$.
	$Function$ действует из $\mathbb{R}^{windowSize}$ в $\mathbb{R}$ и пока кажется, что можно предоставить некоторый фиксированный выбор этих возможных функций: $MEAN$, $MAX$, $MIN$, $SUM$, $MUL$, $VAR$, $MEDIAN$, $NORMALIZE$, хотя, конечно, это не выглядит гибко, но если подумать, то многие функции можно выразить через имеющуюся арифметику на треках и изменение размера корзины.
\end{itemize}

\subsection*{Примеры использования}
\begin{lstlisting}
newTrack := if (track1 >= track2 AND track1 <= track2 + 100) then track1 else track2

newTrack := X = track1, Y = track2 in (if X > Y then X else Y)

newTrack := 1 / (2 ^ track1)

newTrack := X = track1 in (if track2 > 20 then X else 0)

Y - X + (if (if Y > 0 then Y else X) < 0 then Z else 0) * Y
\end{lstlisting}

\newpage
\section*{Описание языка (грамматика)}
\begin{lstlisting}
STATEMENT = ID := EXPR 
          | EXPR
          | show ID
EXPR      = ID
          | NUM
          | (EXPR)
          | EXPR + EXPR
          | EXPR - EXPR
          | EXPR * EXPR
          | if PRED then EXPR else EXPR
PRED      = TERM
          | not TERM
          | (PRED)
          | PRED or PRED
          | PRED and PRED
TERM      = true | false | REL
REL       = EXPR <= EXPR | EXPR >= EXPR | EXPR == EXPR | EXPR < EXPR | EXPR > EXPR
NUM       = [1-9][0-9]* | 0
ID        = [a-zA-Z_][0-9a-zA-Z_]*
\end{lstlisting}

\newpage
\section*{Однознаная грамматика}

\begin{itemize}
\item Главное выражение:
\begin{lstlisting}[style=nonumbers]
	S -> %track_name% <- E
			| show %track_name%
			| E
\end{lstlisting}

\item Арифметика на треках:
\begin{lstlisting}[style=nonumbers]
	E -> E + T
			| E - T
			| T
	T -> T * X
			| T / X
			| X
	X -> X ^ P
			| P
	P -> (E) 
			| if PRED then E else E
			| %track_name% 
			| %number%
\end{lstlisting}

\item Предикаты:
\begin{lstlisting}[style=nonumbers]
	PRED -> PRED or A
			| A
	A -> A and B
			| B
	B -> (PRED)
			| not PRED
			| true
			| false
			| R
	R -> E < E
			| E > E
			| E <= E
			| E >= E
			| E == E
			| E != E
\end{lstlisting}

\end{itemize}

\newpage
\section*{Грамматика без левой рекурсии}
\begin{lstlisting}
	STATEMENT -> ID ":=" TRACK_EXPR 
	    			| "show" ID 
	   				| TRACK_EXPR
	TRACK_EXPR -> E_TERM SUM_SUB
	SUM_SUB -> "+" E_TERM SUM_SUB 
	      		| "-" E_TERM SUM_SUB 
	     		|.
	E_TERM -> E_FACTOR MUL_DIV
	MUL_DIV -> "*" E_FACTOR MUL_DIV 
	      		| "/" E_FACTOR MUL_DIV 
	      		| .
	E_FACTOR -> "(" TRACK_EXPR ")" 
	    		| "if" PREDICATE "then" TRACK_EXPR "else" TRACK_EXPR 
	    		| ID 
	    		| NUMBER
	PREDICATE -> B_TERM OR_PRED
	OR_PRED -> "or" B_TERM OR_PRED 
	         	|.
	B_TERM -> NOT_FACTOR AND_PRED
	AND_PRED -> "and" NOT_FACTOR AND_PRED 
	      		|.
	NOT_FACTOR -> "not" B_FACTOR 
	      		| B_FACTOR
	B_FACTOR -> "(" PREDICATE ")" 
	    		| RELATION
	    		| "true" 
	    		| "false" 
	RELATION ->  TRACK_EXPR "<=" TRACK_EXPR 
	    		|TRACK_EXPR ">=" TRACK_EXPR 
	    		|TRACK_EXPR "==" TRACK_EXPR 
	    		|TRACK_EXPR "!=" TRACK_EXPR
	    		|TRACK_EXPR ">" TRACK_EXPR 
	    		|TRACK_EXPR "<" TRACK_EXPR 
	ID -> [a-zA-Z_][a-zA-Z_0-9]*
	NUM -> %float_num_regex%
\end{lstlisting}

\newpage
\section*{Parsing Expression Grammar}
\begin{lstlisting}
	STATEMENT <- ID ":=" TRACK_EXPR 
	    			/ "show" ID 
	   				/ TRACK_EXPR
	TRACK_EXPR <- E_TERM ("+" E_TERM / "-" E_TERM)*
	E_TERM <- E_FACTOR ("*" E_FACTOR / "/" E_FACTOR)*
	E_FACTOR <- "(" TRACK_EXPR ")" 
	    		/ "if" PREDICATE "then" TRACK_EXPR "else" TRACK_EXPR 
	    		/ ID 
	    		/ NUMBER
	PREDICATE <- B_TERM ("or" B_TERM)*
	B_TERM <- NOT_FACTOR ("and" NOT_FACTOR)*
	NOT_FACTOR <- "not" B_FACTOR 
	      		/ B_FACTOR
	B_FACTOR <- "(" PREDICATE ")" 
	    		/ RELATION
	    		/ "false" 
	    		/ "true" 
	RELATION <-  TRACK_EXPR "<=" TRACK_EXPR 
	    		  / TRACK_EXPR ">=" TRACK_EXPR 
	    		  / TRACK_EXPR "==" TRACK_EXPR 
	    		  / TRACK_EXPR "!=" TRACK_EXPR
	    		  / TRACK_EXPR ">" TRACK_EXPR 
                  / TRACK_EXPR "<" TRACK_EXPR 
	ID <- [a-zA-Z_][a-zA-Z_0-9]*
	NUM <- %float_num_regex%
\end{lstlisting}


\end{document}