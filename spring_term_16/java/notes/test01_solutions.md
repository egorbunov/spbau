### Разбор летучки 1

#### 1
*Вопрос: зачем нужны final классы?*

---

Мы не хотим, чтобы кто-то изменял поведение функции в наследниках. Почему? 

1. Потому! Так делается в стандартной библиотеке или в вашем большом проеке, чтобы 
2. Ускорение работы в силу невертуальности вызовов финализированного класса. Но в новой Java вызовы стали effictevely final и JVM следит за тем, переопределяли ли вы метод в наследниках и если да, то делает его виртуальным.

#### 2
*Вопрос: Что выведет код?*
```Java
class Test01 {
    static int x;
    static {
        System.out.println("1");
        x = 3;
    }
    {
        System.out.println("2");
    }
    public Test01() {
        System.out.println("3");
    }
}

public class Main {
    public static void main(String[] args) {
        System.out.println("4");
        Class<?> x = Test01.class;
        System.out.println("5");
        System.out.println(Test01.x);
        System.out.println("6");
        Test01 t = new Test01();
    }
}
```

---

Ответ: `3, 4, 1, 3, 6, 2, 3`

1. Не правда, что класс инициализируется когда подгружается
2. Инициализация происходит тогда, когда с точки зрения логики программы, она должна быть проведена.
3. `Test01.class`. В этой строке JVM просто подгружает класс и возвращает ссылку на него, но использоваться он пока не начал, потому он должен быть инициализирован.
4. Перед `Test01.x` должна быть проведена статическая инициализация.  
5. Мы не знаем, когда JVM загружает в себя класс, но это и не важно, т.к. инициализация всё равно происходит перед первым использованием данных класса и вызовов статических методов класса. Но де-факто класс подгружается в JVM в момент входа в область видимость использования класса.

#### 3
Вопрос: *Что выведет код?*
```Java
try {
    sout("1");
    throw new ExcpetionA();
} catch (Exception e) {
    sout("2");
    throw new ExceptionB();
} finally {
    sout("3");
}
```

---

**Ответ:** вывод: `1,2,3` и `ExceptionC`.

1. Блок `finally` выполняется вообще всегда и то, что в нём есть всегда побеждает
2. Во время бросания `ExceptionB` JVM просто такая: ок, я тебя взяла и пойду в блок `finally`, 
 
#### 4
Задание: Ресурс X, кот. используется в try с ресурсами может генерить исклюючения при создании (`EA`), работе (`EB`) и закрытии (`EC`) ресурса. Напишите кусок кода, которые обрабатывает все три типа исключений и выводит `A` в случае `EA`, `B` в сл. `EB` и `C`, если `EC`

---

```Java
try {
    ... // try1
} catch(...) {
    ... // Ловит исключение из try1
}
```

```Java
try(X x = new X()) {
    ... // try1
} catch(...) {
    ... // catches Exceptions from try1 or from (X x = new X()), but 
        // if excpetion EB occured inside try block and after that (we need to close x)
        // exception EC occured during x.close(), it will be suppressed by EB (EB.addSuppressed(EC))
}
```

**Ответ:**
```Java
try(X x = new X()) {
} catch(EA e) {
    sout("A")
} catch(EB e) {
    if (EC in e.getSuppressedExceptions()) {
        sout("C")
    } else {
        sout("B")
    }
} catch(EC c) {
    sout("C")
}

```

#### 5
Задание: что выведет код?
```Java
Integer a = 1;
Integer b = 1;
int c = 1;
double d = 1;
Double e = 1;
sout(a == b);
sout(a == c);
sout(a == d);
sout(a == e);
```

---

* Кэширование маленьких целых можно отключить, но если запускаете JVM без настроет, то она есть. 
* `a == b` это `true` т.к. кэширование маленьких интов
* `a == c` это `true` т.к. произойдёт unboxing Integer в int
* `a == d` аналогичен `a == c`, будет unboxing
* `a == e` в Java8 не скомпилируется, т.к. это разные классы обёртки (lol), а в предыдущих  версиях Java будет возвращён `false` т.к. это разные объекты, но маленькие целые `Double` тоже кэшируются, но они, конечно же отличны от `Integer`
* Если писать `Integer a = new Integer(1)`, то будет создан новый объект, никакого кэширования

#### 6
*Вопрос*: переписать трай с ресурсами без него, но с тем же поведением.

---

Смотри в интернете или в `lec_03_exceptions.md`

#### 7
*Вопрос: какие приемущества получает программист от того, что Java исполняется на виртуальной машине?*

---

1. Кроссплатформенность (но это не основное приемущество, так что не нужно кукарекать)
2. Самое нужное -- это управление памятью за вас виртуальной машиной 
3. Песочница: можно её ограничивать и прочее
4. JIT-компиляция (АМ утвержает (а мы верим), что можно написать один код на C++ и Java так, что динамическим JIT-анализом (в runtime) будут в Java проведены такие оптимизации, что машинных инструкций будет меньше, чем для C++)
