\input{env.tex}
\title{Алгоритмы. Домашнее задание №7}
\author{Горбунов Егор Алексеевич}

\begin{document}
\maketitle

\task{Сильная ориентация графа}
\textit{Нужно ориентировать рёбра данного неориентированного графа $G(V,E)$ за $\bigO{|V|+|E|}$ так, чтобы получившийся граф был сильно связным.}\\
Из курса по дискретной математике нам известно, что неориентированный граф $G$ может быть сильно ориентирован тогда и
только тогда, когда он двусвязный, т.е. в $G$ нет точек сочленения. Искать точки сочленения в графе $G$ мы умеем за 
$\bigO{|V|+|E|}$ и первым делом запустим алгоритм поиска точек сочленения и в случае, если точки сочленения будут найдены, то сообщим о том, что данный граф $G$ не допускает сильной ориентации.\\
Далее будем считать, что граф $G$ не содержит точек сочленения, т.е. двусвязен, а значит допускает сильную ориентицаю
рёбер. Построим такую ориентацию рёбер:
\begin{algorithmic}
\Procedure{DFS}{$v$}
	\xstate{isUsed$[v]=true$}
	\For{$u \in \Gamma{(v)}$}
		\xstate{\Call{orientEdgeFromTo}{$v,u$}}
		\If{isUsed$[u]=false$}
			\xstate{\Call{DFS}{$u$}}
		\EndIf
	\EndFor
\EndProcedure
\end{algorithmic}
Тут $\Gamma{(v)}$ --- множество вершин, смежных с $v$. 
Вызов <<orientEdgeFromTo($v,u$)>> просто ориентирует ребро $\lbrace v, u \rbrace$ так: $(v,u)$, т.е. $v\rightarrow~u$.
Таким образом мы просто ориентируем все рёбра в порядке обхода в глубину от предка к сыну, а если встречаем обратное ребро, которое может вести из вершины $v$ к её предку, то ориентируем его от сына ($v$) к предку.\\
Этот алгоритм будет работать по следующим причинам: рассмотрим 2 любые вершины $v$ и $u$ графа $G'$, который 
есть ориентированный граф $G$ по процедуре, приведённой выше. Посмотрим на эти вершины в дереве, которое было построено поиском в глубину. Пускай $p$ --- это любой общий предок вершины $v$ и $u$ в этом дереве (он  может совпадать с $v$ или $u$).
Заметим теперь, что т.к. $G$ --- двусвязный, то нам известно (из того же курса дискретной математики), что \textbf{любые $2$ вершины $G$ лежат на некотором цикле}, но 
это значит, что $p$ и $v$ лежат на некотором цикле. Ясно тогда, что найдётся такая вершина $x$, что в дереве, построенном обходом в глубину, $v$ будет предком $x$ ($x$ может совпадать с $v$) и из $x$ будет торчать обратное ребро
в $p$:
\begin{figure}[ht!]
\centering
\begin{tikzpicture}
\GraphInit[vstyle=Classic]
\tikzset{VertexStyle/.append style = {minimum size = 3pt}}
\tikzstyle{EdgeStyle}=[post]
\Vertex[Math,x=-0.5,y=-1.25]{v}
\Vertex[Math,x=2,y=-2.5]{u}
\Vertex[Math,x=0,y=0]{p}
\Vertex[Math,x=-1.5,y=-2]{x}
\Edge[style=dashed](p)(v)
\Edge[style=dashed](p)(u)
\Edge[style=dashed](v)(x)
\tikzset{EdgeStyle/.append style = {bend left}}
\Edge[color=red,style=dashed](x)(p)
\end{tikzpicture}
\end{figure}
Но тогда мы видим, что из $v$ можно пройти в $u$ так: $v \rightarrow \ldots \rightarrow x \rightarrow p \rightarrow \ldots \rightarrow u$. Таким образом мы показали, что для любых двух вершин $v$ и $u$ графа $G'$, который есть ориентация графа $G$ по приведённой процедуре, из $v$ существует путь по ориентированным рёбрам в $u$. А это значит, 
что граф $G'$ сильно связный. \xqed

\task{Смена корня дерева за $\bigO{V}$}
\textit{Дерево $T$ на $V$ вершинах задано как массив $parent[1..V]$, где $parent[i]$ --- индекс отца $i$-ой вершины, $r$ --- корень дерева $T$ и $parent[r]=-1$. Нужно сменить корень дерева с $r$ на $q$ и перестроить массив $parent$ так, чтобы он задавал корневое дерево с корнем в $q$. Сложность: $\bigO{V}$}\\
Будем обозначать корневое дерево $T$ с корнем в $r$ как $T_r$.
Рассмотрим путь от вершины $r$ до $q$ в дереве $T_r$ и этот же путь после перестроения в дереве $T_q$
\begin{figure}[ht!]
\centering
\subfloat[Исходное дерево $T_r$]{
	\begin{tikzpicture}
	\GraphInit[vstyle=Classic]

	\begin{scope}[VertexStyle/.append style = {minimum size = 5pt, inner sep = 0pt, color=black}]
        \Vertex[Math,x=0,y=0]{r}   
        \Vertex[Math,x=1,y=-1]{v_1}
        \Vertex[Math,x=2,y=-2]{v_k}
        \Vertex[Math,x=3,y=-3]{q}
	\end{scope}

	\tikzset{VertexStyle/.style = {shape = regular polygon,regular polygon sides=3,
								   minimum size = 30pt,
								   inner sep=0pt,
								   draw}}
	\Vertex[Math,x=-0.5,y=-1,LabelOut=false]{A_r}
	\Vertex[Math,x=0.5,y=-2,LabelOut=false]{A_1}
	\Vertex[Math,x=1.5,y=-3,LabelOut=false]{A_k}
	\Vertex[Math,x=3,y=-4,LabelOut=false]{A_q}

	\Edge(r)(v_1)
	\Edge[style=dashed](v_1)(v_k)
	\Edge(v_k)(q)
	\Edge(r)(A_r)
	\Edge(v_1)(A_1)
	\Edge(v_k)(A_k)
	\Edge(q)(A_q)

	\end{tikzpicture}
}
\hspace{50pt}
\subfloat[Перестроенное дерево: $T_q$]{
		\begin{tikzpicture}
	\GraphInit[vstyle=Classic]

	\begin{scope}[VertexStyle/.append style = {minimum size = 5pt, inner sep = 0pt, color=black}]
        \Vertex[Lpos=180,Math,x=3,y=0]{q}   
        \Vertex[Lpos=180,Math,x=2,y=-1]{v_k}
        \Vertex[Lpos=180,Math,x=1,y=-2]{v_1}
        \Vertex[Lpos=180,Math,x=0,y=-3]{r}
	\end{scope}

	\tikzset{VertexStyle/.style = {shape = regular polygon,regular polygon sides=3,
								   minimum size = 30pt,
								   inner sep=0pt,
								   draw}}
	\Vertex[Math,x=3.5,y=-1,LabelOut=false]{A_q}
	\Vertex[Math,x=2.5,y=-2,LabelOut=false]{A_k}
	\Vertex[Math,x=1.5,y=-3,LabelOut=false]{A_1}
	\Vertex[Math,x=0,y=-4,LabelOut=false]{A_r}

	\Edge(r)(v_1)
	\Edge[style=dashed](v_1)(v_k)
	\Edge(v_k)(q)
	\Edge(r)(A_r)
	\Edge(v_1)(A_1)
	\Edge(v_k)(A_k)
	\Edge(q)(A_q)
	\end{tikzpicture}
}
\end{figure}\\
Тут $A_1,\ldots,A_k,A_r,A_q$ --- есть те подграфы дерева $T_r$, что не задействованы при спуске от $r$ к $q$.
Заметим, что в для любой вершины $v \in A_1\cup \ldots \cup A_k \cup A_r \cup A_q$ значение $parent[v]$ для дерева $T_r$ равно
значению $parent[v]$ для дерева $T_q$, т.к. у такой вершины предок не изменился при перестроении. Предки изменились только лишь 
у вершин на пути от $r$ до $q$: $r,v_1,\ldots,v_k,q$, причём так, что если $v_i$ был предком $v_{i+1}$ в $T_r$, то $v_{i+1}$
стал предком $v_{i}$ в $T_q$. Исходя из вышесказанного построим процедуру перестроения массива $parent$ из $T_r$ в $T_q$:

\begin{algorithmic}
\Procedure{changeRoot}{$parent[1..V], r, q$}
	\xassign{$prev$}{$-1$}
	\xassign{$cur$}{$q$}
	\While{$cur \neq -1$}
		\xassign{$next$}{$parent[cur]$}
		\xassign{$parent[cur]$}{$prev$}
		\xassign{$prev$}{$cur$}
		\xassign{$cur$}{$next$}
	\EndWhile
\EndProcedure
\end{algorithmic}
В силу того, что существует единственный путь из $q$ в $r$ в дереве, тело цикла отработает максимум $V$ раз, а значит сложность алгоритма: $\bigO{V}$. \xqed

\task{}
\task{Число путей через ребро за $\bigO{V}$}
\textit{Дано дерево $T(V,E)$. Нужно для каждого ребра $e\in E$ вычислить, сколько простых путей через него проходит.}\\
Ясно, что каждое ребро $e=\lbrace v,u \rbrace \in E$ есть мост (иначе, в $T$ нашёлся бы цикл). А это значит, что при удалении $e$ 
граф $T$ распадётся на 2 компоненты связности $C_1$ и $C_2$. Пусть $v\in C_1$, а $u \in C_2$. Обозначи $T_1=C_1\setminus \lbrace v \rbrace$, $T_2=C_2\setminus \lbrace u \rbrace$. Тогда число путей, проходящий через $\lbrace v, u \rbrace$ равно числу путей, 
которые начинаются с $v$, проходят через $u$ и уходят в $T_2$ плюс число путей,
которые начинаются с $u$ проходят через $v$ и уходят в $T_1$ плюс всевозможные соединения ребром $\lbrace v,u \rbrace$ путей из 
$v$ в $T_1$ и из $u$ в $T_2$, ну и конечно нельзя забывать само ребро в качестве пути из 2 вершин.
\begin{figure}[ht!]
\centering
	\begin{tikzpicture}
	\GraphInit[vstyle=Classic]
	\begin{scope}[VertexStyle/.append style = {minimum size = 5pt, inner sep = 0pt, color=black}]
        \Vertex[Lpos=90,Math,x=-0.5,y=0]{v}   
        \Vertex[Lpos=90,Math,x=0.5,y=0]{u}
	\end{scope}
	\tikzset{VertexStyle/.style = {shape = regular polygon,regular polygon sides=3,
								   minimum size = 30pt,
								   inner sep=0pt,
								   draw}}
    \Vertex[Math,x=-2,y=0,LabelOut=false]{T_1}
    \Vertex[Math,x=2,y=0,LabelOut=false]{T_2}
	\Edge(v)(u)
	\Edge(T_1)(v)
	\Edge(u)(T_2)
	\end{tikzpicture}
\end{figure}\\
Итого путей через $\lbrace v,u \rbrace$:
\begin{equation*}
\begin{split}
|T_1|+|T_2|+|T_1||T_2|+1 &=\\
(|T_1|+1)(|T_2+1|) &=\\
(|V|-|T_2|-1)(|T_2| + 1)
\end{split}
\end{equation*}
Тут воспользовались тем очевидным фактом, что $|V|=|T_1|+|T_2|+2$. Теперь запустим поиск в глубину в дереве $T$ из любой
вершины, он подвесит нам дерево $T$ за некоторую вершину. Рассмотрим вершину $v$ в уже подвешенном дереве $T$ и заметим,
что поддерево $T_v$, с корнем в вершине $v$ есть одна из компонент связности, на которую распадётся граф, если удалить ребро
$\lbrace v, parent(v) \rbrace$, где $parent(v)$ --- непосредственный родитель $v$ в обходе в глубину. А значит, число
путей, проходящих через ребро $\lbrace v, parent(v) \rbrace$, по вышеизложенным соображениям, равно: $size(T_v)(|V|-size(T_v))$,
где $size(T_v)$ --- число вершин в $T_v$ включая саму $v$. Итого получим следующий алгоритм:
\begin{algorithmic}
\Function{DFS}{$v$}
	\xstate{isUsed$[v]=true$}
	\xassign{$size$}{$0$}
	\For{$e = (v,u) \in \Gamma{(v)}$}
		\If{isUsed$[u]$ = false}
			\xassign{$childSize$}{\Call{DFS}{$u$, $v$}}
			\xassign{$pathCnt[e]$}{$childSize\cdot(|V|-childSize)$}
			\xassign{$size$}{$size + childSize$}
		\EndIf
	\EndFor
	\xreturn{$size$}
\EndFunction
\end{algorithmic}
Это поиск в глубину, он отработает за $\bigO{|V|+|E|}=\bigO{|V|}$, т.к. входной граф --- дерево. \xqed
\task{}

\end{document}