\input{env.tex}
\title{Алгоритмы. Домашнее задание №3}
\author{Горбунов Егор Алексеевич}

\begin{document}
\maketitle

\task{про слегка перемешавшиеся патроны}
\begin{enumerate}[label=(\alph*)]
\item \small[ сортировка за $\bigO{nk}$ \small] Ясно, что т.к. $1$-ый по порядку патрон не мог оказаться дальше, чем на $k$-ой позиции, то
за $\bigO{k}$ операций легко найти его, пробежавшись по первым $k$ элементам и поменять местами с текущим патроном на первой позиции. Теперь на первой позиции нужный патрон. Тогда аналогично для $2$-ого по порядку патрона: он точно не дальше, чем на $k+1$ позиции. Тогда опять за $\bigO{k}$ операций находим его и сажаем на $2$-ую позицию. И т.д. мы после $i$-ого шага будем иметь первые $i$ патронов в отсортированном порядке, причём операций затрачено $\bigO{ki}$. Итого в конце будем иметь отсортированный массив, за $\bigO{kn}$ \xqed
\item \small[ сортирока за $\bigO{n+I}$ \small] Для $i=0$ число инверсий в массиве $\leq k-1$. Аналогично для остальных $i$. Но тогда инверсий в перестановке патронов $\bigO{n(k-1)}$ = $\bigO{nk-n}$. Т.е. $I \leq (nk-n)$. У нас есть алгоритм из предыдущего пункта, который работает за $\bigO{nk}$. Но $\bigO{nk}=\bigO{n + (nk-n)}=\bigO{n+I}$ \xqed
\item Предположим, что можем отсортировать патроны быстрее, чем за $\Omega{n\log{k}}$, но тогда, если $k=n$, то можем отсортировать обычный массив, без доп. условий на элементы, быстрее, чем за $\bigO{n\log{n}}$, что невозможно \xqed
\item Рассмотрим алгоритм из пункта (a). На каждом $i$-ом шаге этого алгоритма мы ищем минимум среди элементов с номерами $i,\ldots,i+k$. Заметим, что это можно реализовать используя кучу: добавим первые $k$ элементов массива в кучу, с операцией $extractMin$, извлечём минимум, положим его на место первого элемента массива (тут куча не могла сломаться, если что), а потом добавим в кучу $k+1$ элемент и снова извлечём минимум. Таким образом всего операций с кучей $\bigO{n}$, а высота кучи всегда $\bigO{k}$, а значит суммарная сложность алгоритма $\bigO{n\log{k}}$ \xqed
\end{enumerate}

\task{$p_i$-ые порядковые статистики}

\task{про перестановку $p$ максимизирующую сумму $a_{p(i)}b_i$}
Очевидно, что максимальная такая сумма равна:
\[\sum_{i=1}^{n}{a_{sort_a(i)}b_{sort_b(i)}}\]
Действительно, пускай в сумме $\sum_{i=1}^{n}{a_ib_i}$ нет слагаемого $a_{max}b_{max}$ ($a_{max}$ --- максимальный элемент в $a$, $b_{max}$ аналогично, но вместо него есть слагаемые $a_{max}b_i + b_{max}a_j$. Покажем тогда, что $a_{max}b_{max}+a_jb_i > a_{max}b_i + b_{max}a_j$, т.е. произведение максимальных брать выгоднее:
\[
	(a_{max}b_i+b_{max}a_j)-(a_{max}b_{max}+a_jb_i) = a_{max}(b_i-b_{max}) + a_j(b_{max}-b_i) = 
	  (a_{max}-a_j)(b_i-b_{max}) \leq 0 
\]
Тут $sort_a$ - перестановка, соответствующая сортировке элементов массива $a$ по убыванию (или по возрастанию). Аналогично $sort_b(i)$
Тогда перестановку $p$ нужно задать таким образом, чтобы, $a_{p(i)}$ был элементом, стоящим на той же позиции в $a$ после его сортировки, что и $b_i$ в массиве $b$ после сортировки. Ясно, что такая перестановка это:
\[p = sort_a^{-1}\circ sort_b\]
Тогда соответственно:
\[p(i) = sort_a^{-1}\circ sort_b(i) = \overbrace{sort_a^{-1}(\overbrace{sort_b(i)}^{\text{индекс } b_i\text{ в отсортированном массиве } b})}^{\text{индекс элемента в массиве } a \text{, что после сортировки попал бы на позицию } i}\]
тут $sort_a^{-1}$ --- обратная перестановка. \xqed

\task{про кучу}
Построим такую кучу, что при сортировке число вызовов операции \code{SiftDown} максимально. В данной задаче рассматривается $max$-куча.
Чтобы максимизировать число вызовов \code{SiftDown} при сортировке, будем строить кучу так, чтобы число вызовов \code{SiftUp} было максимальным, а это будет тогда, когда элементы поднимаются с самого конца кучи. Собственно алгоритм будет <<обратен>> алгоритму сортировке:
\begin{enumerate}
\item Добавить в кучу элемент $i$ (в начале $i = 1$, потом $2$ и т. д.):
\item Заменить его с $1$ в куче
\item Выполнить для элемента $i$ \code{SiftUp}
\item Вставить $1$ в конец кучи
\end{enumerate}
Элемент $1$ после каждого добавления находится в конце кучи, что обеспечивает нам максимум вызовов операции \code{SiftUp}.
$n$ вызовов операции \code{SiftUp} дают временную сложность $\bigO{n\log{n}}$.
Алгоритм обратен алгоритму сортировки, а значит число вызовов \code{SiftDown} будет так же максимально при сортировке, как и число вызовов \code{SiftUp}. \xqed
\end{document}