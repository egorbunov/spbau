\input{env.tex}
\title{Алгоритмы. Домашнее задание №5}
\author{Горбунов Егор Алексеевич}

\begin{document}
\maketitle

\task{Максимальное по весу паросочетание за $\bigO{n}$}
Дан граф $G(V,E)$ и $w:E \rightarrow \mathbb{Z}$. Нужно придумать алгоритм нахождения веса $W$ такого паросочетания $M$, что
$W = \sum_{e\in M}{w(e)} \rightarrow \max$, если:
\begin{enumerate}[label=(\alph*)]
\item $G$ -- дерево\\
Дерево $G$ можно подвесить за любую вершину и получить корневое дерево (поиск в глубину от любой вершины это и делает).
Будем тогда считать, что $G$ -- подвешенное дерево с корнем $root$. Решать поставленную задачу будем последовательно 
для всех поддеревьев дерева $G$ начиная с листьев. Введём: \\
\begin{tabular}{lp{15cm}}
  $A[v]=$ & размер наибольшего паросочетания $M$ в поддереве с корнем в вершине $v$, причём $M$ содержит ребро $(v,u)$, 
  где $u\in Children(v)$\\
  $B[v]=$ & размер наибольшего паросочетания $M$ в поддереве с корнем в вершине $v$, причём $M$ не содержит рёбер $(v,u)$, 
  где $u\in Children(v)$\\
\end{tabular}
Тут $Children(v)$ --- множество детей вершины $v$ в подвешенном дереве $G$. А размер максимального паросочетания в поддереве
с корнем в $v$ тогда находится так: $\max(A[v],B[v])$ (определения $A$ и $B$ дополняют друг друга). \\
Ясно, что если $v$ --- лист, то $A[v]=B[v]=0$. Если же $v$ --- не лист, то посчитаем $B[v]$ и $A[v]$ на основе его детей:
\[ 
	B[v] =  \sum_{u\in Children(v)}{\max(A[u],B[u])} 
\]
Т.к. из определению $B[v]$ максимальное паросочетание, не содержащее рёбер $(v,u)$, где $u\in Children(v)$, будет просто
складываться из паросочетаний в поддеревьях с корнями в детях $v$.\\
С $A[v]$ немного сложнее: будем добавлять к паросочетанию ребро $(v,u)$, где $u\in Children(v)$, так же, т.к. после этого
в паросочетании уже есть ребро, инцидентное $u$, то к весу паросочетания нужно добавить $B[u]$ и ещё добавить сумму размеров
максимальных паросочетаний в поддеревьях с корнями в $Children(v)\setminus \lbrace u \rbrace$. И это всё нужно помаксимизировать, используя
$u$ как параметр:
\[
	A[v] = \max_{u \in Children(v)}{\big( w(v, u) + B[u] + \sum_{x \in Children(v)\setminus \lbrace u \rbrace}{\max(A[x], B[x])}   \big)}
\]
Тут $w(v,u)$ --- вес ребра $(v,u)$. Т.к. $B[v] =  \sum_{u\in Children(v)}{\max(A[u],B[u])}$, то 
\[ 
	\sum_{x \in Children(v)\setminus \lbrace u \rbrace}{\max(A[x], B[x])} = B[v] - \max(A[u]B[u])
\]
А значит:
\[
	A[v] = B[v] + \max_{u \in Children(v)}{\big( w(v, u) + B[u] - \max(A[u]B[u])   \big)}
\]
Таким образом мы считаем $A[v]$ и $B[v]$ для всех вершин дерева $G$, причём для того, чтобы посчитать $B[v]$ мы тратим
$\bigO{|Children(v)|}$ операций, как и для подсчёта $A[v]$, что видно из приведённых выше формул. А значит для того, чтобы
посчитать $A[root]$ и $B[root]$ нам понадобиться $\bigO{E}$ операций, а т.к. в дереве на $n$ вершинах $n-1$ ребро, то
мы сможем сделать это за $\bigO{n}$. В качестве ответа выдаём $\max{(A[root], B[root])}$. \xqed

\item $G$ -- цикл\\
Выберем в цикле вершину $x$. Ей инцидентны ровно 2 ребра: $e_1=(x,u)$ и $e_2=(v,x)$. Ясно, что если максимальному по весу паросочетанию
$M$ ребро $e_1$ принадлежит, то $e_2$ точно не принадлежит и наоборот. Рассмотрим граф $G\setminus \lbrace e_1 \rbrace$
--- это дерево. Тогда найдём в нём за $\bigO{n}$ паросочетание максимальное по весу. Таким
образом мы получили некоторое паросочетание $M_1$. Аналогичным образом, но удаляя из графа не $e_1$, а $e_2$ получим некоторое
паросочетание $M_2$ (всё за $\bigO{n}$, т.к. паросочетание ищутся в графе без цикла). Тогда ответом на задачу будет:
$\max{(W(M_1), W(M_2))}$. Действительно, пусть $W(M_1)>W(M_2)$. Предположим, что существует паросочетание $M:\ W(M)>W(M_1)$.
Невозможно, чтобы $M$ не содержало $e_1$, т.к. иначе оно было бы максимальным паросочетанием в графе $G\setminus \lbrace e_1 \rbrace$,
но тогда оно было бы равно $M_1$, значит $e_1 \in M$, а $e_2 \notin M$, т.е. $M$ -- максимальное паросочетание в графе 
$G\setminus \lbrace e_2 \rbrace$, т.е. $M=M_2$, но $W(M_1) > W(M_2)$. Пришли к противоречию, а значит паросочетание, построенное 
приведённой выше процедурой максимально. И построено оно за $\bigO{n}$, т.к. мы всё что мы сделали --- это поискали дважды
максимальное паросочетание в дереве на $n$ вершинах. \xqed

\item $G$ -- связный граф на $n$ вершинах и $n$ рёбрах\\
Заметим, что граф $G$ отличается от дерева одним ребром и в графе $G$ есть один единственный простой цикл. Рассмотрим
обход в глубину графа $G$ начиная с какой-либо вершинки, которую обозначим как $root$. Мы получим дерево, причём при
обходе в глубино мы пройдём по $n-1$ прямому ребру и один единственный раз встретим обратное ребро, которое и образует цикл
в графе $G$. Пусть это ребро $e$ и в графе этому ребру смежны лишь 2 других ребра $e_1$ и $e_2$, которые принадлежат обходу
в глубину. Заметим, что максимальному паросочетанию по весу в графе $G$ могут одновременно лишь принадлежать либо $e_1$ и $e_2$
(и то, если они не смежны), либо $e$. Удаление любого из этих рёбер из графа делает граф деревом. Тогда аналогичными 
пункту $(b)$ рассуждениями легко понять, что ответом на вопрос о максимальном паросочетании будет:
$\max{(maxMatch(G\setminus \lbrace e \rbrace), maxMatch(G\setminus \lbrace e_1 \rbrace), maxMatch(G\setminus \lbrace e_2 \rbrace))}$.
Т.е. выбирается максимальное по весу среди трёх максимальных паросочетаний в 3-х различных деревьях, что асимптотически
работает за $\bigO{n}$ \xqed
\end{enumerate}

\task{Про кактус}
Должно быть, это как-то аккуратно сводится к поиску паросочетания в каких-то деревьях...=)
\task{Число перестановок на $n$ элементах без неподвижных точек за $\bigO{n^2}$}
Будем находить последовательно число перестановок без неподвижных точек для множества из $1,2,\ldots,n$ элементов. 
Хранить ответы будет в массиве $A[1..n]$, т.к. ответ на вопрос задачи будет лежать в $A[n]$.\\
Число перестановок с $k$ неподвижными точками равно: ${n \choose k}A[n-k]$, т.е. мы закрепляем $k$ неподвижных точек, а
оставшаяся часть перестановки не должна содержать таковых. Тогда число перестановок с как минимум $1$ неподвижной точкой
равно: $\sum_{k=1}^{n}{{n \choose k}A[n-k]}$. А тогда число перестановок на $n$ элементах без неподвижных точек равно:
\[
	A[n] = n! - \sum_{k=1}^{n}{{n \choose k}A[n-k]}
\]
Тут нужно положить, что $A[0]=1$. 
Запишем для нескольких $n$:
\begin{align*}
A[1] & = 1! - {1 \choose 1}A[0] \\
A[2] & = 2! - {2 \choose 1}A[1] - {2 \choose 2}A[0]\\
A[3] & = 3! - {3 \choose 1}A[2] - {3 \choose 2}A[1] - {3 \choose 3}A[2]\\
\ldots
\end{align*}
Заметим, что биномиальные коэффициенты можно пересчитывать, например, по треугольнику паскаля: 
${n \choose k} = {n-1 \choose k-1} + {n-1 \choose k}$ и тратить на каждый следующий биномиальный коэффициент $\bigO{1}$
операций. Аналогично можно пересчитывать факториал $n!$ запоминая значение с предыдущего шага (т.е. подсчёта предыдущего $A[i]$)
или же просто предподсчитав их за $\bigO{n}$ и сохранив в массиве. Видим таким образом, что на подсчёт $A[k]$ нам требуется
$\bigO{k}$ операций, а значит, что т.к. для подсчёта ответа --- $A[n]$ нужно посчитать все $A[k],\ k\in \lbrace 1,\ldots,n-1\rbrace$
то суммарно на получение ответа уйдёт $\bigO{n^2}$. \xqed 

\task{Вероятность выпадения $k$ орлов за $\bigO{nk}$}
Даны $n$ монет с вероятностью выпадения орла $p_i,\ i \in \lbrace 1,\ldots,n \rbrace$ каждая. Все монетки подкидываются
и что-то выпадает...нужно найти вероятность выпадения $k$ орлов за $\bigO{nk}$.\\
Разложим все монетки подряд и будем считать следующую величину: 
\begin{center}
$P[n,k]$ --- вероятность выпадения $k$ орлов используя первых $n$ монет
\end{center}
Ясно, что:
\[
P[n,k] = P[n-1,k](1-p_n)+P[n-1,k-1]p_n
\]
Т.е. либо среди первых $n-1$ монеты уже выпало ровно $k$ орлов, тогда нам нужно домножить вероятность этого на вероятность
того, что $n$-ая монета даст нам решку, либо среди первых $n-1$ монеты выпал лишь $k-1$ орёл, тогда нам нужно, чтобы 
$n$-ая монета упала орлом. Других вариантов нет.\\
Итого, нам нужно заполнить таблицу размера $(n+1) \times (k+1)$, причём:
\[ 
\begin{array}{c}
P[n,k]=0,\ k > n\\
P[n,0]=\prod_{i=1}^{n}{(1-p_i)} 
\end{array}
\]
И считаем идя слева направо, сверху вниз. Ответ будет лежать в правом нижнем углу: $P[n,k]$. Таким образом нам нужно
посчитать $nk$ элементов таблицы, а это как раз делается за $\bigO{nk}$, т.к. каждый элемент уходит $\bigO{1}$ времени. \xqed
\task{Про группоид}
Дан группоид --- множество $M$ из $g$ элементов с заданной на нём бинарной операцией <<произведения>> и 
замкнутый относительно неё. Дано произведение из $n$ элементов $M$:
\[
	a_1\cdot a_2 \cdot a_3 \cdot \ldots \cdot a_n
\]
Нужно, расставляя скобки, определить за $\bigO{n^3g^2}$, какие различные элементы можно получить считая это произведение.
Будем поступать почти так же, как в задаче на нахождение порядка произведения матриц произведение матриц:
\hfill\\
\begin{center}
\begin{tabular}{lcp{15cm}}
\hline
  $D[i,j]$ & $=$ & $Bool[1..g]$ --- массив, что, если $D[i,j][g_k]=True$, то $g_k \in M$ можно получить как результат произведения $a_i\cdot a_{i+1} \cdot \ldots \cdot a_j$, а если $D[i,j][g_k]=False$, то нельзя\\
\hline
\end{tabular}
\end{center}
\hfill\\

Считать $D[i,j]$ будем по мере увеличения $(j-i)$. Все массивы
$D[i,j]$ заполнены $False$ изначально, только $D[i,i]$ такие, что $D[i,i][a_i]=True$.\\
Ясно, что зная все возможные различные результаты произведения $a_i\cdot \ldots \cdot a_k$ и все возможные результаты
произведения $a_{k+1}\cdot \ldots \cdot a_j$ для всех $k$ между $i$ и $j$ мы получаем, при помощи процедуры, приведённой
ниже, все возможные результаты произведения $a_{i}\cdot \ldots \cdot a_{j}$.\\
\newpage
\begin{algorithmic}[1]
\For{\xfor{$k$}{$i$}{$j-1$}}
	\For{$x \in M$}
		\For{$y \in M$}
			\If{$D[i,k][x] = True$ AND $D[k+1,j][y] = True$}
				\xstate{$D[i,j][x \cdot y] = True$}
			\EndIf
		\EndFor
	\EndFor
\EndFor
\end{algorithmic}

Заметим, что данная процедура занимает $\bigO{ng^2}$, т.к. внешний цикл работает за $\bigO{n}$ и тело цикла перебирает
всевозможные произведения за $\bigO{g^2}$.\\
Так нам нужно посчитать все $D[i,j]$ выше главной диагонали, т.к. ответ будет находится в ячейке $D[1,n]$, а подсчёт нужно производить по диагоналям, начиная с главной диагонали и поднимаясь выше и выше...Таким образом нам нужно найти $D[i,j]$
в $\frac{n^2}{2}$ ячейках, а значит суммарная сложность алгоритма = $\bigO{n^3g^2}$. \xqed
\\\textit{PS: замечу, что все выделения памяти под $D$, очевидно, влезают во временные рамки. А в силу конечности группоида
мы можем это производить индексацию по его элементам за константное время. }
\end{document}