\input{env.tex}
\title{Алгоритмы. Домашнее задание №11}
\author{Горбунов Егор Алексеевич}

\begin{document}
\maketitle

\task{online-соединение вершин}
\textit{
\textbf{Задача:} Изначально в графе $G$ $|V|$ вершин и нет рёбер. Нужно online обрабатывать запросы
\begin{itemize}
	\item соединить ребром пару вершин
	\item по вершине узнать размер связной компоненты, в которой вершина лежит и самую лёгкую вершину в
	это компоненте
\end{itemize}
Амортизированное время на запрос --- $\bigO{\alpha{(|V|)}}$\\
}
\textbf{\textit{Решение:}} Для решения будем хранить вершины в СНМ с использованием эвристики сжатия путей и
объединения по рангу. Вначале для каждой $v \in V(G)$ выполним $MakeSet(v)$:
\begin{algorithmic}
\Procedure{MakeSet}{$v$}
	\xassign{$parent(v)$}{$v$}
	\xassign{$size(v)$}{$1$} // размер компоненты связности, в которой $v$ лежит
	\xassign{$lightest(v)$}{$v$} // самая лёгкая вершина в компоненте, где лежит $v$
\EndProcedure
\end{algorithmic}
Изначально у нас $|V|$ компонент связности размера $1$. Каждое множество --- дерево, которое содержит вершины
одной компоненты связности. Будем всегда хранить валидную информацию о компоненте (размер и самую лёгкую вершину)
в корне дерева, соответствующего этой компоненте. Изначально ($|E(G)|=0$) вся информация валидна по построению процедуры
$MakeSet$. Научимся правильно её обновлять при добавлении ребра (добавление ребра есть объединение деревьев --- компонент связности)...
\begin{algorithmic}
\Procedure{$Connect$}{$v, u$}
	\xassign{$c_v,\ c_u$}{$Find(v),\ Find(u)$} // стандартная реализация $Find$ со сжатием путей
	\If{$c_v = c_u$}
		\textbf{return}
	\EndIf
	\If{$size(c_v) > size(c_u)$}
		\xstate{$swap(c_u,c_v)$}
	\EndIf
	\xassign{$parent(c_v)$}{$c_u$}
	\xassign{$size(c_u)$}{$size(c_v)+size(c_u)$}
	\xassign{$lightes(c_u)$}{$\min_{w(v)}{(lightest(c_u), lightest(c_v))}$} // выбор вершины с $min$ весом
\EndProcedure
\end{algorithmic}
Таким образом для добавления ребра $(v,u)$ вызывается процедура $Connect(v,u)$. А для ответа на запрос про размер
компоненты, которой принадлежит вершина $v$ нужно найти $c_v = Find(v)$ и в качестве ответа вернуть $size(c_v)$.
Аналогично для самой лёгкой вершины, только возвращаем $lightet(c_v)$. Собственно мы добавили в стандартную реализацию
СНМ лишь дополнительное свойство $lightest$...В качестве ранга используем размер компоненты связности. Таким образом
известно, что все операции работают за $\bigO{\alpha{(|V|)}}$, где $\alpha$ --- обратная функция Аккермана. \xqed

\task{Существование пути по рёбрам не тяжелее $x$}
\textit{
\textbf{Задача:} Дан неор. граф $G(V,E)$ с весами на рёбрах и $n$ запросов вида $(v, u, x)$ --- существует ли путь
между вершинами $v$ и $u$ по рёбрам не тяжелее $x$? В offline нужно ответить на эти запросы за
$\bigO{|E|\log{|V|}+n\log{n}+n\alpha{(|V|)}}$.\\
}
\textbf{\textit{Решение:}} Рассмотрим какой-то один запрос $(v,u,x)$. Давайте удалим из графа $G$ все рёбра,
вес которых $> x$. Но тогда, если вершины $v$ и $u$ попали в разные компоненты связности в этом новом графе, то
ответ на запрос, соответственно, <<нет>>, иначе ответ <<да>>, т.е. путь из $v$ в $u$ по рёбрам веса $\leq x$ существует.


Окей. Теперь нам нужно как-то быстро уметь находить компоненты связности графа, если из него выкидываются рёбра более
определённого веса. Воспользуемся тем, что все запросы $(v,u,x)$нам известны и будем последовательно на
них отвечать по мере увеличения $x$. Отсортируем все запросы по мере увеличения $x$: $(v_i,u_i,x_i),\ x_{i-1} \leq x_i$.
Рассмотрим изначально граф на вершинах из $V$, но без рёбер. Вспомним задачу $1$ и будем последовательно добавлять
в граф рёбра, по мере увеличения их веса. Как только вес рассматриваемого для добавления ребра стал больше $x_1$,
так сразу заканчиваем добавлять и отвечаем на запрос $(v_1,u_1,x_1)$, т.к. на данный момент в нашем строящемся графе
содержатся лишь те рёбра, чей вес $\leq x_1$. На запрос мы отвечаем за $\bigO{\alpha{(|V|)}}$ в силу того, что каждая
компонента связности у нас есть множество в СНМ и если $Find(v_1)=Find(u_1)$, то путь есть, а иначе его нет. Далее продолжим добавлять рёбра в граф (по возрастанию весов рёбер) и остановимся, когда вес рассматриваемого для добавления
ребра стал больше $x_2$, и.т.д...


Таким образом нам потребовалось:
\begin{itemize}
	\item Отсортировать запросы по возрастанию $x$: $\bigO{n\log{n}}$
	\item Отсортировать рёбра по весу: $\bigO{|E|\log{|E|}}$
	\item Ответить последовательно на $n$ запросов выполнив на каждый запрос $2$ вызова процедуры $Find$:
	$\bigO{n\alpha{|V|}}$
\end{itemize}
Итого: $\bigO{|E|\log{|V|}+n\log{n}+n\alpha{(|V|)}}$. \xqed
\end{document}
