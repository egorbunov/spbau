### Haskell и заметки по функциональному программированию

#### Monoid
```hs
class Monoid a where
    mempty :: a
    mappend :: a -> a -> a
    mconcat :: [a] -> a
```

#### Functor
Functor в Haskell -- класс типов, "принимающий на вход" конструктор типа с одним параметром.
```hs
class Functor (f :: * -> *) where
    fmap :: (a -> b) -> f a -> f b
    (<$) :: a -> f b -> f a
```
Т.е. конструктор типа `f`, принимающий один параметр, является функутором тогда и только тогда, когда он реализует метод `fmap`.

Таким образом `f` называют функтором, если он относится к классу `Functor`.

Функтор `f` есть что-то в духе отображения из `a` в `f a`, причём
такого, что для любого морфизма `m :: a -> b`, задан морфизм `fmap m :: f a -> f b` удовлетворяющий следующим свойствам:
* `fmap id` = `id` (про тождественность)
* `fmap f . g` = `fmap f . fmap g` (про композицию)

Хорошим примером однопараметрического типа, не являющегося функтором (для него не ясно как реализовывать `fmap`) служит множество. Пускай у нас `f = (*) 2`, `g = min 3`, тогда ясно, что `(f . g) a = min 3 (2 * a)`. Если мы применим `fmap f . g` к множеству `{1,2,3,4,5}`, то получим множество `{2,3}`. Если же мы сначала применим функцию `fmap g` к множеству, то получим `{1,2,3}`, а потом применив `fmap f` получим `{2,4,6}`!

#### Applicative functor
```hs
class Functor f => Applicative (f :: * -> *) where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
    (*>) :: f a -> f b -> f b
    (<*) :: f a -> f b -> f a
```

#### Alternative
```hs
class Applicative f => Alternative (f :: * -> *) where
    empty :: f a
    (<|>) :: f a -> f a -> f a
    some :: f a -> f [a]
    many :: f a -> f [a]
```

#### Monad
```hs
class Applicative m => Monad (m :: * -> *) where
    (>>=) :: m a -> (a -> m b) -> m b
    (>>) :: m a -> m b -> m b
    return :: a -> m a
    fail :: String -> m a
```

### Просто заметки

1. Если `f :: a -> b` есть обычная функция, то `f :: a -> m b` есть монадическая функия! Композиция обычных функций - это `(.)`, а композиция монадических функций - это `>=>`.
2. Есть некоторое сходство в функторах и монадах, т.к. `fmap :: (a -> b) -> f a -> f b`, а `(<<=) :: (a -> m b) -> m a -> m b`.

### Ссылки
* [Категории как шаблон проектирования](http://www.haskellforall.com/2012/08/the-category-design-pattern.html)
* [Функторы как шаблон проектирования](http://www.haskellforall.com/2012/09/the-functor-design-pattern.html)
